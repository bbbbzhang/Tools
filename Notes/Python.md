# 1、认识python脚本

>编写python程序的文件，称为python的脚本或程序
>要求当前的python脚本的文件后缀名必须是.py


#### pycharm使用注意

> 需要明确的知道你当前pycharm选择的python环境

#### 注释

> 注释就是一段说明文字，并不会被执行
> 在python的脚本中，开头的第一个字符如果是 # 那么就是注释了

#### print()  输出函数

> print可以在程序中输出一些内容，字符串，数字。。。
> 函数就是为了完成一些功能，例如：print就是为了输出数据


#### 变量 

```python
# 什么是变量？
# 变量就是用一个英文字符串来记录或标记一些数据，并且这个被标记的数据是可以变化的
# num = 10 的理解
# 就是把数据 10 赋值给变量 num使用，之后就可以使用num来代替这个10的数据
```

#### 命名规范

变量的命名要有规范

+ 变量名可以使用字母，数字，下划线_，
+ 不能以数字开头
+ 严格区分大小写
+ 不要使用中文
+ 不要使用关键字 if else True  False print

**另外  变量的命名规范适用于脚本名称和后期的函数名及其它命令规范**



#### 变量的定义方式

> 定义变量时 要注意遵守变量命名规范

```python
#第一种 变量定义方式
a = 10
b = 20

#第二种定义方式
a,b = 30,40
```

#### 思考：如何实现 以下两个变量的数据相互交换

```python
# 定义两个变量
a = 10
b = 20
# 交换两个变量的值

# 。。。

'''
普通方式，完成变量数据的交换
1，把a变量的值 赋值给c  ，此时 c变量中 就是 10
2，把b变量的值 赋值给a  ， 此时 a变量中 就是 20
3，把c变量的值 赋值给b  ， 此时 b变量中 就是 10
'''
# c = a
# a = b
# b = c

# 利用python定义比变量的语法来实现 变量的数据交换

a,b = b,a
```



# 2、数据类型


### 什么是数据类型？

> 数据类型就是数据的表现形式
>
> 比如 你好 就是一个字符串，200 就是一个数字
>
> 在程序当中除了这种常用的字符和数字外还有很多其它的数据表现形式

### type() 函数，可以返回当前的数据类型

```python
s = 'iloveyou'
res = type(s) 
print(res)  # <class 'str'>  str == string
```

### 1. 字符串类型

- 单双引号都可以定义字符串
- 三引号也可以定义字符串
- 单双引号定义的字符串不能随意换行，需要在换行时指明换行符
- 字符串中的引号可以互相嵌套，但是不能嵌套自己（例如不能在单引号中嵌套单引号，除非转义）
- 字符串中可以使用转义字符，如 \r \n \t ...
- 如果不想在字符串中实现转义字符可以在字符定义时 加 `love = r'\nihao \shijie'`

```python
# 定义方式就是使用 单引号 或者 双引号
love = 'iloveyou'
hello = "你好 世界"

# 也可以使用三引号实现大字符串的定义，一般用于大文本字符串的定义，并且大字符串，可以换行
s = '''
比如说这一个
很长很长的文章内容。。。
'''
```

### 2.数字类型

+ int   整型
+ float 浮点类型
+ complex 复数
+ bool  布尔类型（True，False）

```python
# 数字类型 Number
'''
int   整型
float 浮点类型
complex 复数
bool  布尔类型（True，False）
'''
varn = 521
varn = -1111

varn = 3.1415926

varn = 0x10  # 十六进制

varn = b'001100111' # bytes

# 复数
varn = 5+6j  # complex

# 布尔类型  bool
varn = True
varn = False
# print(varn,type(varn))

# 数值类型可以参与运算
a = 10
b = 20
print(a+b)
```

### 3.List列表类型

+ 列表用来表示一系列数据，例如： 需要记录一组数字或其它数据
+ 列表中存储的数据可以是任意类型的
+ 在需要记录多个数据时，可以使用中括号进行定义 [],
+ 并且每个数据之间使用逗号分隔 ,
+ 例如以下数据，定义了几组数字
+ 列表中存储的每一组数据，称为元素
+ 列表中存储的数据，可以通过下标的方式进行获取
+ 那么列表中元素的值可不可以存储一个列表,称为 二级列表（二维列表） 或者 多级列表 （多维列表）

```python
'''
关于列表中的下标
  0   1   2    3    4 
['a','b',521,'pai',3.1415926]
 -5   -4   -3  -2   -1
'''
```

### 4. tuple 元组类型的定义

+ 在定义多个数据内容时，可以选择使用List列表类型
+ 还可以使用元组类型来定义，
+ 元组和列表非常像，都时用于存储多个数据时使用
+ 元组使用小括号进行定义（），列表使用中括号进行定义
+ **元组的最大特点就是值不能被改变**

```python
vart = (1,2,3,'a','b')
# 元组的其它定义方式
vart = 1,2,3
```

注意在定义元组时，如果元组中只有一个元素，那么需要加, 不然就不是元组类型了

### 5.Dict字典类型

+ 字典也是用于存储一组或多组数据时使用，使用大括号 {}来定义
+ 字典是 键值对 的存储方式 name ：admin
+ 键和值之间使用冒号进行分隔，多组键值对之间使用逗号分隔
+ 键必须是字符串或数字类型，值可以是任意类型
+ 键名不能重复，值可以重复

```python
# 比如需要记录一本书的相关数据 书名，作者，价格，。。。
vard = {'title':'<<鬼谷子>>','author':'鬼谷子','price':'29.99'}
# print(vard,type(vard))
# {'title': '<<鬼谷子>>', 'author': '鬼谷子', 'price': '29.99'} <class 'dict'>

# 获取字典中的值
print(vard['title'])
# 字典中的键不能重复使用，否则会覆盖
vard = {'a':10,'b':10,'c':20,'a':'aa',1:'abcdef','2':'2222'}
# print(vard)
```

tip: 在python之前的版本中，字典是无序的

---

### 6.set集合类型

+ set集合是一个 无序且元素不重复的 集合的数据类型
+ set集合使用 中括号或者set()方法来定义
+ 如果需要定义一个空集合时 只能使用 set()方法,因为大括号时定义的空字典
+ 集合主要用于运算，交集，差集，并集，对称集合

```python
a = {1,2,3,'a'}
# 给集合添加元素
# a.add('b')
# 无法获取集合中的单个元素，但是可以添加和删除
# a.discard('a')
# print(a)
# 检查当前的元素是否在集合中
# print(1 in a)


# 集合主要用于运算，交集，差集，并集，对称集合
a = {1,2,3,'a','b'}
b = {1,'a',22,33}

print(a & b) # 交集  {1, 'a'}
print(a - b) # 差集 {'b', 2, 3}  a 集合有，b集合没有的
print(a | b) # 并集 {1, 2, 3, 33, 'a', 'b', 22} 两个集合，放到一起，并且去重
print(a ^ b) # 对称差集 {33, 2, 3, 'b', 22} 
```

### 总结数据类型

```python
'''
字符串 string
数字类型 Number
    整型 int
    浮点 float
    复数
    布尔 bool
列表  list
元组  tuple
字典  dict
集合  set

可变数据类型：列表，字典，集合
不可不数据类型： 字符串，数字，元组

容器类型数据 ： 字符串，列表，元组，集合，字典
非容器类型数据： 数字，布尔类型
'''
```

### 数据类型转换

+ 什么是数据类型转换？
  + 把一个数据类型转换为另一个数据类型，例如 字符串转为数字
+ 为什么需要数据类型转换？
  + 因为不同的数据类型之间不能运算
+ 数据类型转换的形式？
  + 自动类型转换
  + 强制类型转换


#### 自动类型转换

```python
# 自动类型转换
# 当两个不同的值进行运算时，结果会向更高的精度进行计算
# True ==> 整型 ==> 浮点 ==> 复数
a = 123
b = True  # 在和数字运算时 True转为数字1，False转为数字 0
# print(a+b)
# print(12.5+22)
# print(True+3.14)
```

#### 强制类型转换

> python中的每个数据类型都有对应的方法，可以对数据类型进行转换

+ str() 可以把所有的其它数据类型转换为字符串类型
+ int() 字符串转数字类型时，如果字符串中时纯数字，可以转换
  + 其它容器类型不能转为数字int类型
+ float() 浮点类型的转换和int类型一样，不过转换的结果是浮点类型
+ bool() 可以把其它类型转换布尔类型的True或False
  + 总结，哪些情况转bool的结果是 False
  + `'',0,0.0,False,[],{},(),set()`
+ list() 列表
  + 数字类型是 非容器类型，不能转换为列表
  + 字符串 转换为列表时  会把字符串中的每一个字符当做列表的元素
  + 集合 可以转换为 list列表类型
  + 元组 可以转换为 list列表类型
  + 字典 可以转换为 list列表类型,只保留了字典的键 key
+ tuple() 元组
  + 数字类型 非容器类型，不能转换为元组
  + 其它容器类型的数据进行转换时，和列表一样
+ set() 集合
  + 数字类型 非容器类型，不能转换为 集合
  + 字符串,列表，元组 可以转为 集合 结果是无序的
  + 字典转换为集合时，只保留了字典的键 key
+ dict() 字典
  + 数字类型 非容器类型，不能转换为 字典
  + 字符串不能直接转换为 字典
  + 列表可以转换为字典，要求是一个二级列表，并且每个二级元素只能有两个值
  + 元组可以转换为字典，要求是一个二级元组，并且每个二级元素只能有两个值

# 3、数据类型详解-字符串

+ 回顾字符串的定义方式
+ 了解转义字符
+ 字符串相关的操作
+ 字符串格式化的方法
+ 字符串相关函数



### 字符串的定义方式

1. 单引号定义字符串 ‘ ’
2. 双引号定义字符串 “ ”
3. 三引号定义字符串 ‘’‘内容’‘’或者 “”“内容”“”
4. 字符串定义时，引号可以互相嵌套

### 转义字符

> 一个普通的字符出现在转义符 \ 的后面时，实现了另外一种意义

+ \ 转义符，续行符。
  + 作为转义符时，在\后面出现的字符可能会实现另外一种意义。
  + 作为续行符时，在行尾使用了\后，可以换行继续书写内容
+ \n 代表一个换行符
+ \r 代表光标位置（从\r出现的位置开始作为光标的起点）
+ \t 代表一个水平制表符（table 缩进）
+ \b 代表一个退格符
+ `\\` 反转义\，输出了\，取消\的转义效果

**把转义字符作为普通字符输出,在字符串的前面加 r' '**

示例：

```python
# \ 续行符
#续行符
# vars = '123' \
#        '456'
# print(vars)

# \ 转义符，在字符出现的特定字符有着特定的意义
# \n  代表一个换行符
# vars = '岁月是把杀猪刀，\n\n但是它拿长得丑的人一点办法都没有。。。'

# \r 代表光标的位置（从\r出现的位置开始作为光标的起点）
# vars = '岁月是把杀猪刀，\r但是它拿长得丑的人一点办法都没有。。。'

# \t 水平制表符（table 缩进）
# vars = '岁月是把杀猪刀，\t但是它拿长得丑的人一点办法都没有。。。'

# \b 退格符
# vars = '岁月是把杀猪刀，\b但是它拿长得丑的人一点办法都没有。。。'

# \\ 一个\是转义符，在这个符号前在定义一个\ 就会取消转义。变成一个普通的\输出
# vars = '岁月是把杀猪刀，\\n但是它拿长得丑的人一点办法都没有。。。'

# 把转义字符作为普通字符输出,在字符串的前面加 r''
vars = r'岁月是把杀猪刀，\b但是它拿长得丑的人一点办法都没有。。。'
print(vars)
```

### 字符串相关的操作

+ 字符串 + 操作
+ 字符串 * 操作
+ 字符串 [] 切片操作
  + 字符串[开始值：结束值：步进值]
    开始值：默认为0，结束值默认是最后一个下标，步进值默认为1

示例：

```python
# - 字符串 + 操作
vara = '君不见，黄河之水天上来，奔流到海不复回.'
varb = '君不见，高堂明镜悲白发，朝如青丝暮成雪'
# res = vara + varb
res = '将进酒 '+'李白'
# print(res)

# - 字符串 * 操作
# vars = '鸡你太美,' * 5
# print(vars)
# 鸡你太美鸡你太美鸡你太美鸡你太美鸡你太美

# - 字符串 [] 切片操作 ****
# 字符串的索引操作，字符串中只能使用[]下标 访问，不能修改
'''
0 1 2 3 4 5 6 7 8 9 10 ....
君不见，黄河之水天上来，奔流到海不复回
                    -4 -3 -2 -1
'''
vars = '君不见，黄河之水天上来，奔流到海不复回'
# print(vars[5])
# print(vars[-5])

'''
字符串的切片操作
str[开始值：结束值：步进值]
开始值：默认为0，结束值默认是最后一个下标，步进值默认为1
'''
# print(vars)
# print(vars[5]) # 写一个值就是获取指定下标的元素
# print(vars[2:5]) # 从2下标开始取值，一直到下标5之前，能取到2，取不到5
# print(vars[4:8:2]) # 黄河之水 ==> 黄之
# print(vars[::]) # 从头取到尾
# print(vars[::2]) # 从头取到尾，每隔一个取一个
# print(vars[::-1])  # 字符串倒转过来
# print(vars[::-2])  # 字符串倒转过来，每隔一个取一个
# print(vars[1::])  # 不见，黄河之水天上来，奔流到海不复回
# print(vars[1::2])  # 不，河水上，流海复
```

### 字符串格式化的方法

+ format
+ f

示例：

```python
# 1 format  普通方式
a = '李白'
# vars = '{}乘舟将欲行，互闻岸上踏歌声'.format(a)
# vars = '{}乘舟将欲行，互闻岸上{}'.format(a,'踏歌声')
format会把里面的变量追加到花括号占位符里面

# 2 format  通过索引传参                           0   1   2
# vars = '{2}乘舟将欲行，互闻岸上{1}'.format('a','b','c')

# 3 format  关键字传参
# vars = '{a}乘舟将欲行，互闻岸上{b}'.format(a='李白',b='踏歌声')

# 4 format  容器类型数据传参
# vars = '豪放派：{0[0]}，婉约派：{0[1]}，蛋黄派：{0[2]}'.format(['李白','辛弃疾','达利园'])

data = {'a':'辛弃疾','b':'蛋黄派'}
vars = '{a}乘舟将欲行，互闻岸上{b}'.format(**data)

# 3.7中新增的 格式化方法 f方法
vars = f'{data["a"]}乘舟将欲行，互闻岸上{data["b"]}'
# print(vars)

# 限定小数的位数
# vars = '圆周率是多少：{:.2f}'.format(3.1415926)
# print(vars)
```

### 字符串相关函数

> 官方文档：内置类型：字符串
>
> https://docs.python.org/3.7/library/stdtypes.html#text-sequence-type-str

#### (一) 英文字符与字符检测相关函数

```python
# 字符串相关函数 (一) 英文字符与字符检测相关函数
vars = 'iloveyou'
# 返回字符串的副本，该字符串的首个字符大写，其余小写。
# str.capitalize()
res = vars.capitalize()
# 把字符串中的一个单词的首字母大写
res = vars.title()
# 把字符串全部改为 大写
res = vars.upper()
# 把字符串全部改为 小写
res = vars.lower()
# 字符串中的大小写字符转换，大写转小写，小写转大写
res = vars.swapcase()

# 检测字符串是否为全部大写字母组成
res = vars.isupper()
# 检测字符串是否为全部小写字母组成
res = vars.islower()
# 检测字符串是否符合标题title的要求
res = vars.istitle()
# 检测字符串是否由数字和字母组成，如果字符串中包含来非数字字母的其它字符，则返回False
res = vars.isalnum()
# 检测字符串是否全部由字符(包含英文字符和中文)组成
res = vars.isalpha()
# 检测字符串是否由纯数字字符组成
res = vars.isdigit()
# 检测当前字符串是否为 空格 字符组成 ' '
res = vars.isspace()

# 检测字符串是否以指定的字符开始的，也可以指定开始和结束的位置
res = vars.startswith('y')
# res = vars.startswith('y',5)
# 检测字符串是否以 指定的字符 结束的，也可以指定开始和结束的位置
# res = vars.endswith('y')
res = vars.endswith('e',1,5)

print(res)
```

### （二）字符串 查找与操作相关函数 重点重点重点

示例：

```python
#  ** find() 方法 ，找到则返回字符中符合条件的第一个字符出现的索引位置。未找到返回 -1
res = vars.find('you')
# print(vars[res:res+3])

# index() 方法
# res = vars.index('youe') # 找到则返回索引位置，未找到则报错 ValueError
# print(res)

vars = 'user_admin_id_123'

# ** split() 方法 可以按照指定的分隔符，把字符串分隔成列表
# res = vars.split('_') # ['user', 'admin', 'id', '123']
res = vars.split('_',2)  # ['user', 'admin', 'id_123']
# print(res)

# rsplit() 方法是从右向左进行，从后向前
# res = vars.rsplit('_')  # ['user', 'admin', 'id', '123']
res = vars.rsplit('_',2)  # ['user_admin', 'id', '123']
# print(res)

# ** join() 方法 ，使用指定的字符串，把一个容器中的元素链接成一个字符串
varlist = ['user', 'admin', 'id', '123']
res = '_'.join(varlist)

# ** strip() 去除字符串左右两侧的指定字符
vars = '  zhangsan  '
res = vars.strip(' ')
vars = '@admin'
res = vars.strip('@')
# print(vars)
# print(res)

# rstrip() 去除字符串右侧的指定字符， lstrip() 去除字符串左侧的指定字符

# ** len() 函数可以获取当前字符串的长度
# print(len(vars))
# print(len(res))


# ** replace() 替换函数
vars = 'iloveyou'
# 找到 love  替换为 live
res = vars.replace('love','live')

vars = 'aabbccddeeabcdef'
#  可以限制替换的次数
res = vars.replace('b','B',2)
# print(res)
```



# 4、数据类型详解-列表

> 列表就是一组有序的数据组合，列表中的数据可以被修改

### 列表的定义

+ 可以使用 中括号进行定义 [] 
+ 也可以使用 list函数 定义
+ 在定义列表中的元素时，需要在每个元素之间使用逗号，进行分隔。[1,2,3,4]
+ 列表中的元素可以是任意类型的，通常用于存放同类项目的集合

### 列表的基本操作

+ 列表定义-[],list()
+ 列表相加-拼接
+ 列表相乘-重复
+ 列表的下标- 获取,更新
+ 列表元素的添加-append()
+ 列表元素的删除
  + del 列表[下标]
  + pop()函数 删除元素



### 列表中切片

> 语法==> 列表[开始索引:结束索引:步进值]

1。 列表[开始索引:]  ==> 从开始索引到列表的最后
2。 列表[:结束值]    ==> 从开始到指定的结束索引之前
3。 列表[开始索引:结束索引] ==> 从开始索引到指定结束索引之前
4。 列表[开始索引:结束索引:步进值] ==> 从指定索引开始到指定索引前结束，按照指定步进进行取值切片
5。 列表[:] 或 列表[::] ==> 所有列表元素的切片
6。 列表[::-1]  ==> 倒着获取列表的元素

示例：

```python
varlist = ['刘德华','张学友','张国荣','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']

# 从开始索引到列表的最后
res = varlist[2:] # ['张国荣','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']
# 从开始到指定的结束索引之前
res = varlist[:2] # ['刘德华','张学友']
# 从开始索引到指定结束索引之前
res = varlist[2:6] # ['张国荣', '黎明', '郭富城', '小沈阳']
# 从指定索引开始到指定索引前结束，按照指定步进进行取值切片
res = varlist[2:6:2] # ['张国荣', '郭富城']
# 所有列表元素的切片
res = varlist[:]
res = varlist[::]
# 倒着输出列表的元素
res = varlist[::-1]

# 使用切片方法 对列表数据进行更新和删除
print(varlist)

# 从指定下标开始，到指定下标前结束，并替换为对应的数据(容器类型数据，会拆分成每个元素进行赋值)
# varlist[2:6] = ['a','b','c',1,2,3]
# varlist[2:6:2] = ['a','b'] # 需要与要更新的元素个数对应

# 切片删除
# del varlist[2:6]
del varlist[2:6:2]
```



### 列表相关函数

```python
varlist = ['刘德华','张学友','张国荣','张学友','黎明','郭富城','小沈阳','刘能','宋小宝','赵四']

# len()  检测当前列表的长度，列表中元素的个数
res = len(varlist)

# count() 检测当前列表中指定元素出现的次数
res = varlist.count('张学友')

# append() 向列表的尾部追加新的元素，返回值为 None
varlist.append('川哥')

# insert() 可以向列表中指定的索引位置添加新的元素，
varlist.insert(20,'aa')


# pop() 可以对指定索引位置上的元素做 出栈 操作，返回出栈的元素
res = varlist.pop() # 默认会把列表中的最后一个元素 出栈
res = varlist.pop(2) # 会在列表中把指定索引的元素进行 出栈

varlist = [1,2,3,4,11,22,33,44,1,2,3,4]
# remove() 可以指定列表中的元素 进行 删除,只删除第一个。如果没有找到，则报错
res = varlist.remove(1)

# index() 可以查找指定元素在列表中第一次出现的索引位置
# res = varlist.index(1)
# res = varlist.index(1,5,20) # 可以在指定索引范围内查找元素的索引位置

# extend() 接收一个容器类型的数据，把容器中的元素追加到原列表中
# varlist.extend('123')

# s.clear() # 清空列表内容
# varlist.clear()


# reverse() 列表翻转
varlist.reverse()

# sort() 对列表进行排序
res = varlist.sort() # 默认对元素进行从小到大的排序
res = varlist.sort(reverse=True) # 对元素进行从大到小的排序
res = varlist.sort(key=abs) # 可以传递一个函数，按照函数的处理结果进行排序
```

### 深拷贝与浅拷贝

浅拷贝

> 浅拷贝只能拷贝列表中的一维元素，**如果列表中存在二维元素或容器，则引用而不是拷贝**
>
> 使用cpoy函数或者copy模块中的copy函数拷贝的都是浅拷贝

```python
# 浅拷贝 只能拷贝当前列表，不能拷贝列表中的多维列表元素

varlist = [1,2,3]
# 简单的拷贝 就可以把列表复制一份
newlist = varlist.copy()
# 对新拷贝的列表进行操作，也是独立的
del newlist[1]
# print(varlist,id(varlist))
# print(newlist,id(newlist))
'''
[1, 2, 3] 4332224992
[1, 3] 4332227552
'''

# 多维列表
varlist = [1,2,3,['a','b','c']]

# 使用copy函数 拷贝一个多维列表
newlist = varlist.copy()

'''
print(newlist,id(newlist))
print(varlist,id(varlist))
[1, 2, 3, ['a', 'b', 'c']] 4361085408
[1, 2, 3, ['a', 'b', 'c']] 4361898496
'''
# 如果是一个被拷贝的列表，对它的多维列表元素进行操作时，会导致原列表中的多维列表也发生了变化
del newlist[3][1]

'''
通过id检测，发现列表中的多维列表是同一个元素（对象）
print(newlist[3],id(newlist[3]))
print(varlist[3],id(varlist[3]))
['a', 'c'] 4325397360
['a', 'c'] 4325397360
'''
```

深拷贝

> 深拷贝就是不光拷贝了当前的列表，**同时把列表中的多维元素或容器也拷贝了一份，而不是引用**
>
> 使用copy模块中的 deepcopy 函数可以完成深拷贝

```python
# 深拷贝 就是不光拷贝了当前的列表，同时把列表中的多维元素也拷贝了一份
import copy

varlist = [1,2,3,['a','b','c']]

# 使用 copy模块中 深拷贝方法 deepcopy
newlist = copy.deepcopy(varlist)
del newlist[3][1]

print(varlist)
print(newlist)

'''
    print(newlist[3],id(newlist[3]))
    print(varlist[3],id(varlist[3]))
    ['a', 'c'] 4483351248
    ['a', 'b', 'c'] 4483003568
'''
```



### 列表推到式

>List-Comprehensions
>
>列表推导式提供了一个更简单的创建列表的方法。
>
>常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。
>
>采用一种表达式的当时，对数据进行过滤或处理，并且把结果组成一个新的列表

#### 一，基本的列表推到式使用方式

> 结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据]

示例：

```python
# 1 假设我们想创建一个平方列表

# 使用普通方法完成
varlist = []
for i in range(10):
    varlist.append(i**2)
# print(varlist)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 使用 map函数和list完成
varlist = list(map(lambda x: x**2, range(10)))
# print(varlist)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 使用列表推到式完成 下面这个列表推到式和第一种方式是一样的
varlist = [i**2 for i in range(10)]
# print(varlist)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 2。 '1234' ==> [2,4,6,8]
# 常规方法完成需求
varstr = '1234'
newlist = []
for i in varstr:
    newlist.append(int(i)*2)
# print(newlist)  # [2, 4, 6, 8]

# 使用列表推到式完成上面的需求
newlist = [int(i)*2 for i in varstr]
# print(newlist)  # [2, 4, 6, 8]

# 使用列表推到式+位运算完成
newlist = [int(i) << 1 for i in varstr]
# print(newlist)  # [2, 4, 6, 8]
```

#### 二，带有判断条件的列表推到式

> 结果变量 = [变量或变量的处理结果 for i in 容器类型数据 条件表达式]

示例：

```python
# 0-9 求所有的偶数，==> [0, 2, 4, 6, 8]
# 常规方法完成
newlist = []
for i in range(10):
    if i % 2 == 0:
        newlist.append(i)
# print(newlist) # [0, 2, 4, 6, 8]

# 列表推到式完成
newlist = [i for i in range(10) if i % 2 == 0]
# print(newlist)  # [0, 2, 4, 6, 8]
```

#### 三，对于嵌套循环的列表推到式

```python
'''
# 下面这个 3x4的矩阵，它由3个长度为4的列表组成，交换其行和列
[
 [1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12],
]

==>
[
    [1, 5, 9], 
    [2, 6, 10], 
    [3, 7, 11], 
    [4, 8, 12]
]
'''
arr = [
 [1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12],
]

# 常规方法完成
# newlist = []
# for i in range(4):
#     res = []
#     for row in arr:
#         res.append(row[i])
#     newlist.append(res)
# print(newlist)

# 使用列表推到式完成
newlist = [[row[i] for row in arr] for i in range(4)]
print(newlist)
```



# 5、数据类型详解-元组

> 元组和列表一样都是一组有序的数据的组合。
>
> 元组中的元素一但定义不可以修改，因此元组称为 不可变数据类型

### 元组定义

+ 定义空元组 变量 = (),或者 变量=tuple()
+ 还可以使用 变量 = (1,2,3) 定义含有数据的元组
+ 注意：如果元组中只有一个元素时，必须加逗号 变量=(1,)
+ 特例：变量=1,2,3 这种方式也可以定义为一个元组

### 元组的相关操作

> 由于元组是不可变的数据类型，因次只能使用索引进行访问，不能进行其它操作
>
> 元组可以和列表一样使用切片方式获取元素

### 元组的切片操作

> 元组的切片操作  和列表是一样的

```python
vart = (1,2,3,4,5,5,4,3,2,1)
res = vart[:]  # 获取全部
res = vart[::] # 获取全部
res = vart[1:] # 从索引1开始获取到最后
res = vart[1:3] # 从索引1开始到索引3之前
res = vart[:3]   # 从索引 0 开始 到 索引 3之前
res = vart[1:5:2] # 从索引1开始到索引5之前，步进值为2
res = vart[::2]  # 从索引 0 开始 到 最后 ，步进值为2
res = vart[5:1:-1] # 从索引5开始 到索引 1，步进值为-1  倒着输出
```

### 元组推导式 生成器

>  列表推导式结果返回了一个列表，元组推导式返回的是生成器

    语法：
        列表推导式 ==> [变量运算 for i in 容器]  ==> 结果 是一个 列表
        元组推导式 ==> (变量运算 for i in 容器)  ==> 结果 是一个 生成器

生成器是什么？

> 生成器是一个特殊的迭代器，生成器可以自定义，也可以使用元组推导式去定义
>
> 生成器是按照某种算法去推算下一个数据或结果，只需要往内存中存储一个生成器，节约内存消耗，提升性能

语法：

1. 里面是推导式，外面是一个() 的结果就是一个生成器

2. 自定义生成器，含有yield关键字的函数就是生成器

   > 含有yield关键字的函数，返回的结果是一个迭代器，换句话说，生成器函数就是一个返回迭代器的函数

如何使用操作生成器？

​    生成器是迭代器的一种，因此可以使用迭代器的操作方法来操作生成器

示例代码:

```python
# 列表推导式
varlist = [1,2,3,4,5,6,7,8,9]
# newlist = [i**2 for i in varlist]
# print(newlist) # [1, 4, 9, 16, 25, 36, 49, 64, 81]

# 元组推导式 生成器 generator
newt = (i**2 for i in varlist)
print(newt) # <generator object <genexpr> at 0x1104cd4d0>

# 使用next函数去调用
# print(next(newt))
# print(next(newt))

# 使用list或tuple函数进行操作
# print(list(newt))
# print(tuple(newt))

# 使用 for 进行遍历
# for i  in newt:
#     print(i)
```

# 6、数据类型详解-字典

> 字典也是一种数据的集合，由键值对组成的数据集合，字典中的键不能重复
>
> 字典中的键必须是不可变的数据类型，常用的键主要是：字符串，整型。。。

### 字典的定义

+ 字典可以通过将以逗号分隔的 `键: 值` 对列表包含于花括号之内来创建字典
+ 也可以通过 [`dict`](https://docs.python.org/zh-cn/3.7/library/stdtypes.html#dict) 构造器来创建

 `{'jack': 4098, 'sjoerd': 4127}` 或 `{4098: 'jack', 4127: 'sjoerd'}`

```python
# 1。 使用{}定义
vardict = {'a':1,'b':2,'c':2}

# 2。 使用 dict(key=value,key=value) 函数进行定义
vardict = dict(name='zhangsan',sex='男',age=22)

# 3。 数据类型的转换  dict(二级容器类型) 列表或元组，并且是二级容易才可以转换
vardict = dict([['a',1],['b',2],['c',3]])  # {'a': 1, 'b': 2, 'c': 3}

# 4。zip压缩函数，dict转类型
var1 = [1,2,3,4]
var2 = ['a','b','c','d']

# 转换的原理和上面的第三种 是一个原理
vardict = dict(zip(var1,var2))  # {1: 'a', 2: 'b', 3: 'c', 4: 'd'}
print(vardict)
```

### 字典的操作

```python
var1 = {'a': 1, 'b': 2, 'c': 3}
var2 = {1: 'a', 2: 'b', 3: 'c', 4: 'd'}

# res = var1 +  var2 # XXXX  TypeError
# res = var1 * 3 # xxxx TypeError

# 获取元素
res = var1['a']

# 修改元素
res = var1['a'] = 111

# 删除元素
del var1['a']

# 添加元素
var1['aa'] = 'AA'

# 如果字典中的key重复了，会被覆盖
# var1['aa'] = 'aa'
```

### 成员检测和获取

```python
# 三 成员检测和获取  ,只能检测key，不能检测value
res = 'AA' in var1
res = 'AA' not in var1

# 获取当前字典的长度 只能检测当前又多少个键值对
res = len(var1)

# 获取当前字典中的所有 key 键
res = var1.keys()
# 获取字典中所有的 value 值
res = var1.values()
# 获取当前字典中所有 键值对
res = var1.items()
```

### 字典的遍历

```python
# 四， 对字典进行遍历
# （1）在遍历当前的字典时，只能获取当前的key
for i in var1:
    print(i) # 只能获取 key
    print(var1[i]) # 通过字典的key获取对应value

#（2）遍历字典时，使用 items() 函数，可以在遍历中获取key和value
for k,v in var1.items():
    print(k)  # 遍历时的 key
    print(v)  # 遍历时的 value

print('===='*20)
# (3) 遍历字典的所有key
for k in var1.keys():
    print(k)

print('===='*20)
# (4) 遍历字典的所有 value
for v in var1.values():
    print(v)
```

### 字典的相关函数

```python
#  字典相关函数

# len(字典) #获取字典的键值对个数
# dict.keys() # 获取当前字典的所有key 键，组成的列表
# dict.values() # 获取当前字典的所有 value 值，组成的列表
# dict.items() # 返回由字典项 ((键, 值) 对) 组成的一个新视图
# iter(d) 返回以字典的键为元素的迭代器。

vardict = {'a':1,'b':2,'c':3}

# dict.pop(key) # 通过 key 从当前字典中弹出键值对  删除
# res = vardict.pop('a')

# dict.popitem()   LIFO: Last in, First out.后进先出
# res = vardict.popitem()  # 把最后加入到字典中的键值对删除并返回一个元组

# 使用key获取字典中不存在元素，会报错
# print(vardict['aa'])
# 可以使用get获取一个元素，存在则返回，不存在默认返回None
# res = vardict.get('aa')
# res = vardict.get('aa','abc')

# dict.update(),更新字典,如果key存在，则更新，对应的key不存在则添加
# vardict.update(a=11,b=22)
# vardict.update({'c':33,'d':44})

# dict.setdefault(key[,default])
# 如果字典存在键 key ，返回它的值。
# 如果不存在，插入值为 default 的键 key ，并返回 default 。
# default 默认为 None。
res = vardict.setdefault('aa','123')
print(res)
print(vardict)
```



### 字典推导式

```python
# 把字典中的键值对位置进行交换 {'a':1,'b':2,'c':3}
vardict = {'a':1,'b':2,'c':3}

# 普通方法实现 字典中的键值交换  {1: 'a', 2: 'b', 3: 'c'}
newdict = {}
for k,v in vardict.items():
    newdict[v] = k
# print(newdict)

# 使用字典推导式完成  {1: 'a', 2: 'b', 3: 'c'}
newdict = {v:k for k,v in vardict.items()}
# print(newdict)

# 注意：以下推导式，返回的结果是一个集合，集合推导式
# newdict = {v for k,v in vardict.items()}
# print(newdict,type(newdict))


# 把以下字典中的是偶数的值，保留下来，并且交换键值对的位置
vardict = {'a':1,'b':2,'c':3,'d':4}

# 普通方式完成  {2: 'b', 4: 'd'}
# newdict = {}
# for k,v in vardict.items():
#     if v % 2 == 0:
#         newdict[v] = k
# print(newdict)

# 字典推导式完成  {2: 'b', 4: 'd'}
newdict = {v:k for k,v in vardict.items() if v % 2 == 0}
# print(newdict)
```

# 7、数据类型详解-集合

> 确定的一组无序的数据的组合

+ 确定的？ 当前集合中元素的值不能重复
+ 由多个数据组合的复合型数据（容器类型数据）
+ 集合中的数据没有顺序
+ 功能：成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。

### 集合的定义

+ 可以直接使用 {} 来定义集合
+ 可以使用set()进行集合的定义和转换
+ 使用集合推导式完成集合的定义

**注意：集合中的元素不能重复，集合中存放的数据：Number,Strings,Tuple,冰冻集合**



### 集合的基本操作和常规函数

```python
# 定义集合
vars = {123,'abc',False,'love',True,(1,2,3),0,3.1415,'123'}
# 1。无序。
# 2。布尔类型 True 表示为 1，False 表示为 0，布尔和数字只存在一个
# 3。元素的值不能重复
# {0, 'abc', 'love', True, 3.1415, (1, 2, 3), 123}

# 检测集合中的值
res = '123' in vars
res = '123' not in vars

# 获取集合中元素的个数 len()
# res = len(vars)

# 集合的遍历
# for i in vars:
#     print(i,type(i))

# 向集合中追加元素 add()
res = vars.add('def')

# 删除集合中的元素 随机删除一个元素并返回  abc False True 3.1415
# r1 = vars.pop()


# 指定删除集合中的元素 remove() 返回None，不存在则报错
# res = vars.remove('aaa')

# discard 指定删除集合中的元素，不存在也不会报错
# res = vars.discard('aaa')

# clear() 清空集合
# res = vars.clear()

# update(others) 更新集合，添加来自 others 中的所有元素。
res = vars.update({1,2,3,4,5})

#  当前集合中的浅拷贝并不存在 深拷贝的问题
res = vars.copy()
'''
当前集合中的浅拷贝并不存在 深拷贝的问题
    因为集合中的元素都是不可变，包括元组和冰冻集合
    不存在拷贝后，对集合中不可变的二级容器进行操作的问题
'''
```

### 冰冻集合（了解）

> 定义冰冻集合，只能使用 frozenset() 函数进行冰冻集合的定义

+ 冰冻集合一旦定义不能修改
+ 冰冻集合只能做集合相关的运算：求交集，差集，。。。
+ frozenset() 本身就是一个强制转换类的函数，可以把其它任何容器类型的数据转为冰冻集合

```python
# 定义
vars = frozenset({'love',666,'a',1,'b',2,'521'})
# vars = frozenset([1,2,3])

# 遍历
# for i in vars:
#     print(i)

# 冰冻集合的推导式
res = frozenset({i<<1 for i in range(6)})

# 冰冻集合可以和普通集合一样，进行集合的运算 交集。。。

# copy()
res = res.copy()
# print(res)
```

### 集合的推导式

```python
# 集合推导式
varset = {1,2,3,4}
# (1) 普通推导式
newset = {i<<1 for i in varset }

# (2) 带有条件表达式的推导式
newset = {i<<1 for i in varset if i%2==0}

# (3) 多循环的集合推导式
vars1 = {1,2,3}
vars2 = {4,5,6}
# newset = set()
# for i in vars1:
#     for j in vars2:
#         print(i,j)
#         newset.add(i+j)
# print(newset)

newset = {i+j for i in vars1 for j in vars2}
# print(newset)

# (4) 带条件表达式的多循环的集合推导式
newset = {i+j for i in vars1 for j in vars2 if i%2==0 and j%2==0}
print(newset)
```



### 集合的运算

#### 集合的主要运算

+ 交集  &    set.intersection()   set.intersection_update()
+ 并集  |    union()  update()
+ 差集  -    difference(),difference_update()
+ 对称差集 ^  symmetric_difference()  symmetric_difference_update()

```python
vars1 = {'郭富城','刘德华','张学友','黎明','都敏俊',1}
vars2 = {'尼古拉斯赵四','刘能','小沈阳','宋小宝','都敏俊',1}

#  & 求两个集合相交的部分
res = vars1 & vars2

# | 求两个集合的并集，就是把集合中所有元素全部集中起来，（去除重复）
res = vars1 | vars2

# - 差集运算
res = vars1 - vars2 # vars1有，而，vars2 没有的
res = vars2 - vars1 # vars2有，而，vars1 没有的

# ^ 对称差集
res = vars1 ^ vars2

# 交集运算函数 intersection  intersection_update
# set.intersection()  # 返回交集的结果 新的集合
# res = vars1.intersection(vars2)

# set.intersection_update()  # 没有返回值
# 计算两个集合的相交部分，把计算结果重新赋值给第一个集合
# res = vars1.intersection_update(vars2)


# 并集运算函数  |    union()  update()
# res = vars1.union(vars2)  # 返回并集结果，新的集合
# 求并集运算，并且把结果赋值给第一个集合
# res = vars1.update(vars2) # 没有返回值
# print(vars1)


# 差集运算  函数 difference(),difference_update()
# res = vars1.difference(vars2) # 返回差集结果  新的集合
# 把差集的结果，重新赋值给第一个集合
# res = vars1.difference_update(vars2) # 没有返回值

# 求对称差集
# res = vars1.symmetric_difference(vars2) # 返回对称差集的结果  新的集合

# 把对称差集的运算结果，重新赋值给第一个集合
res = vars1.symmetric_difference_update(vars2)# 没有返回值
```

#### 集合检测

+  issuperset() 检测是否为超集
+  issubset() 检测是否为子集
+  isdisjoint() 检测是否不相交

```python
# 检测 超集  子集
vars1 = {1,2,3,4,5,6,7,8,9}
vars2 = {1,2,3}

# issuperset() 检测是否为超集
res = vars1.issuperset(vars2)  # True  vars1是vars2的超集
res = vars2.issuperset(vars1)  # False

# issubset() 检测是否为子集
res = vars1.issubset(vars2) #  False
res = vars2.issubset(vars1) #  True vars2是vars1的子集

# 检测两个集合是否相交
vars1 = {1,2,3}
vars2 = {5,6,3}
# isdisjoint 检测是否不相交， 不相交返回True，相交则返回False
res = vars1.isdisjoint(vars2)
print(res)
```



# 8、运算符

本章节主要说明Python的运算符。举个简单的例子 **4 + 5 = 9** 。 例子中，**4** 和 **5** 被称为**操作数**，"**+**" 称为运算符。

Python语言支持以下类型的运算符:

- 算术运算符
- 比较（关系）运算符
- 赋值运算符
- 逻辑运算符
- 位运算符
- 成员运算符
- 身份运算符
- 运算符优先级

接下来让我们一个个来学习Python的运算符。

------

### Python算术运算符

| 运算符 | 描述                                            | 实例                      |
| :----- | :---------------------------------------------- | :------------------------ |
| +      | 加 - 两个对象相加                               | a + b 输出结果 31         |
| -      | 减 - 得到负数或是一个数减去另一个数             | a - b 输出结果 -11        |
| *      | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 210        |
| /      | 除 - x 除以 y                                   | b / a 输出结果 2.1        |
| %      | 取模 - 返回除法的余数                           | b % a 输出结果 1          |
| **     | 幂 - 返回x的y次幂                               | a**b 为10的21次方         |
| //     | 取整除 - 向下取接近除数的整数                   | `>>> 9//2 4 >>> -9//2 -5` |

### Python比较运算符

| 运算符 | 描述                                                         | 实例                  |
| :----- | :----------------------------------------------------------- | :-------------------- |
| ==     | 等于 - 比较对象是否相等                                      | (a == b) 返回 False。 |
| !=     | 不等于 - 比较两个对象是否不相等                              | (a != b) 返回 True。  |
| >      | 大于 - 返回x是否大于y                                        | (a > b) 返回 False。  |
| <      | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 | (a < b) 返回 True。   |
| >=     | 大于等于 - 返回x是否大于等于y。                              | (a >= b) 返回 False。 |
| <=     | 小于等于 - 返回x是否小于等于y。                              | (a <= b) 返回 True。  |

### Python赋值运算符

| 运算符 | 描述             | 实例                                  |
| :----- | :--------------- | :------------------------------------ |
| =      | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符   | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符   | c /= a 等效于 c = c / a               |
| %=     | 取模赋值运算符   | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符     | c **= a 等效于 c = c ** a             |
| //=    | 取整除赋值运算符 | c //= a 等效于 c = c // a             |



### Python位运算符

按位运算符是把数字看作二进制来进行计算的。bin()函数可以把数字转为二进制。

Python中的按位运算法则如下：

下表中变量 a 为 60，b 为 13二进制格式如下：

```
a = 0011 1100

b = 0000 1101

-----------------

a&b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
```

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 **-x-1** | (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

### Python逻辑运算符

Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| :----- | :--------- | :----------------------------------------------------------- | :---------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

### Python成员运算符

除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。

| 运算符 | 描述                                                    | 实例                                              |
| :----- | :------------------------------------------------------ | :------------------------------------------------ |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。     |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |

### Python身份运算符

身份运算符用于比较两个对象的存储单元

| 运算符 | 描述                                        | 实例                                                         |
| :----- | :------------------------------------------ | :----------------------------------------------------------- |
| is     | is 是判断两个标识符是不是引用自一个对象     | **x is y**, 类似 **id(x) == id(y)** , 如果引用的是同一个对象则返回 True，否则返回 False |
| is not | is not 是判断两个标识符是不是引用自不同对象 | **x is not y** ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 |

**注：** [id()](https://www.runoob.com/python/python-func-id.html) 函数用于获取对象内存地址。



> is 与 == 区别：
>
> is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。

### Python运算符优先级

以下表格列出了从最高到最低优先级的所有运算符：

| 运算符                   | 描述                                                   |
| :----------------------- | :----------------------------------------------------- |
| **                       | 指数 (最高优先级)                                      |
| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |
| * / % //                 | 乘，除，取模和取整除                                   |
| + -                      | 加法减法                                               |
| >> <<                    | 右移，左移运算符                                       |
| &                        | 位 'AND'                                               |
| ^ \|                     | 位运算符                                               |
| <= < > >=                | 比较运算符                                             |
| == !=                    | 等于运算符                                             |
| = %= /= //= -= += *= **= | 赋值运算符                                             |
| is is not                | 身份运算符                                             |
| in not in                | 成员运算符                                             |
| not and or               | 逻辑运算符                                             |

> 注意：Pyhton3 已不支持 <> 运算符，可以使用 != 代替

### 二进制

> 二进制（binary）在数学和数字电路中指以2为基数的记数系统，以2为基数代表系统是二进位制的。这一系统中，通常用两个不同的符号0（代表零）和1（代表一）来表示 [1]  。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个比特（Bit，Binary digit的缩写） 

### 进制转换

十进制转换为二进制

> 一个十进制整数转换为二进制数采用 "除2取余，逆序排列"法。
>
> 具体做法是：用2整除十进制整数，可以得到一个[商](https://baike.baidu.com/item/商/3820976)和[余数](https://baike.baidu.com/item/余数/6180737)；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来

例如 125 转为 二进制

```
125 / 2 = 62 余 1
62 / 2 = 31 余 0
31 / 2 = 15 余 1
15 / 2 = 7 余 1
7 / 2 = 3 余 1
3 / 2 = 1 余 1
1 / 2 = 0 余 1
余数从低位到高位依此排列： 1 1 1 1 1 0 1
```

二进制转换为十进制

> 方法：“按权展开求和”。
>
> 该方法的具体步骤是先将二迸制的数写成加权系数展开式，而后根据十进制的加法规则进行求和

例如：

```python
# 1 1 1 1 1 0 1
1==> 1*2^6
	+ 64
1==> 1*2^5
	+ 32
1==> 1*2^4
	+ 16
1==> 1*2^3
	+ 8
1==> 1*2^2
	+ 4
0==> 0*2^1
	+ 0
1==> 1*2^0
	+ 1
	= 125
```



### Python位运算符

按位运算符是把数字看作二进制来进行计算的。bin()函数可以把数字转为二进制。

Python中的按位运算法则如下：

下表中变量 a 为 60，b 为 13二进制格式如下：

```
a = 0011 1100

b = 0000 1101

-----------------

a&b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
```

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 **-x-1** | (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

# 9、流程控制

1.python语句的分类
2.流程控制相关的分类
3.顺序结构
4.分支结构
5.循环结构
6.其他流程控制语句

### 1.python语句的分类

    1.单行代码   一行的python代码
    2.代码块/组：
    以冒号作为开始，用缩进划分相同作用域，这样的结构称之为代码块，是一个整体。
    作用域是指作用范围。作用区域，使用了相同的缩进，即有相同的作用域。
    缩进：一个table距离或者四个空格。
    注意：代码块/组中严格区分空格和table，不能混合使用，必须只使用一种方式缩进！

### 2.流程控制的分类

    流程控制：对计算机执行代码的管控就是流程控制。
    
    分类：1.顺序结构 2.分支结构/选择结构 3.循环结构

### 3.顺序结构

    顺序结构是系统默认程序结构，自上而下执行

### 4.分支结构

    结构代码
        a.单项分支
    
           if 条件表达式:
                一条python代码
                一条python代码
                一条python代码
                ...
    
        b.双项分支
            if 条件表达式：
                一条python代码
                一条python代码
                一条python代码
                ...
            else:
                一条python代码
                一条python代码
                一条python代码
                ...
    
        c.多项分支
            if 条件表达式：
                一条python代码
                一条python代码
                一条python代码
                ...
            elif 条件表达式：
                一条python代码
                一条python代码
                一条python代码
                ...
            elif 条件表达式：
                一条python代码
                一条python代码
                一条python代码
                ...
            ...
            else:
                一条python代码
                一条python代码
                一条python代码
                ...
    
        c.巢装分支
            例子：
            if 条件表达式：
                代码语句
                if 条件表达式:
                    代码语句
                else:
                    代码语句
            else：
                代码语句

### 5.循环结构

    必须熟练掌握！
    a.while型循环
        基本结构：
        while 条件表达式:
            代码内容
            代码内容
            代码内容
            ...
    
        带有变化条件的循环
        1.声明变量var
        2.while 进行变量var的判断:
            代码内容
            代码内容
            代码内容
            ...
            3.变量var的改变操作


    b.for..in循环(主要用于遍历容器类数据)
        for 自定义变量 in 容器数据:
            代码内容,可以使用自定义变量
            代码内容,可以使用自定义变量
            代码内容,可以使用自定义变量

### else语句的应用


    循环中可以使用else语句
        while 条件表达式:
            循环语句
            循环语句
            循环语句
            ...
        else:
            代码语句
            代码语句
            代码语句
            ...

### 其他的流程控制语句

    1.break语句
    2.continue语句
    3.pass语句

### 特殊语句：

```
1.exit()
2.quit()
用于结束程序的执行，exit()和quit()之后的代码不会执行。在单纯的循环结构中的作用与break很像，但绝不能混为一谈！！！
```

# 16、模块与包

### 模块

> 定义的一个python的文件，后缀名为.py。这个文件被称为模块。
>
> 模块中通常会定义一些相似的 类，函数等代码内容，提供给别的程序引入后使用。

#### 系统模块

> 系统模块就是一个python的程序脚本，专门提供给我们自己的程序使用。它们是在安装好python环境时，就已经存在的，需要的时候可以使用 import 导入到程序中使用。
>
> import logging，json，time。。。。

#### 自定义模块

> 就是自己创建一个python脚本，定义一些类或方法，供别的脚本导入后使用。

例如定义一个My.py的文件如下

```python
# My.py

# 定义类
class MyException():
    pass

# 定义函数
def func():
    print('我是一个模块中的func函数')
    
# 定义变量
love = 'iloveyou'
```

在定义一个python脚本就可以引入上面的文件作为模块使用

main.py

```python
# main.py 在当前脚本中如果需要使用一些已经定义好的功能时，可以选择对应的模块，导入后使用

# 使用系统模块 time
import time
print(time.time())

# 使用自定义异常处理 模块
import My

# 使用模块中定义的类
obj = My.MyException()
print(obj)

# 使用模块中的函数
My.func()

# 使用模块中定义的变量
print(My.love)

# 想使用模块中的内容时，除了导入模块，还可以在在指定模块中导入指定的内容
from My import love  # 导入My模块中的love变量
from My import love as lv # 导入My模块中的love变量，起个别名
print(love)
print(lv)
```

### 模块中的测试代码

```python
# 自定义模块中，通常只是去定义类或函数，变量，等，并不调用
# 如果在自定义模块中，想要写一些测试代码，在当前模块作为主程序使用时执行，
# 而作为模块被别的程序导入时不执行，那么可以把测试代码写到 下面代码块中
if __name__ == '__main__':
    print('这个位置写的代码只有当前脚本被直接运行时触发')
    
# 特殊的变量 __name__
# __name__ 这个变量，在当前脚本作为模块被别的程序导入是 __name__的值 是当前这个模块的名称
#在当前脚本被作为主程序直接由python解析运行时，__name__的值 是 '__main__'
name = __name__
print(name)
```

### 包

> 包可以理解为是一个文件夹，里面包含了多个python文件。

#### 包的结构：

```python
'''
package/   # 包(文件夹)
├── __init__.py  # 包中的初始化文件
├── a.py         # 包中的模块
├── b.py
└── ps/   # 子包
  ├── __init__.py
  ├── c.py
  └── d.py
'''
```

#### 包的使用方法

```python
# 1. 直接把包当作模块导入，可以用的内容是 __init__.py文件中定义的
# 不推荐这种用法
import package
package.funcpa()

#2。 可以导入模块中的所有内容
# 注意这个内容是由 __init__.py文件中定义的 __all__ 这个变量指定的模块
# 好处是可以直接导入指定的所以模块，并且使用时，直接使用指定的模块名即可
from package import  *
a.funca()
b.funcb()

# 3。 导入指定包中的指定模块
from package import a
a.funca()

# 4。从指定包的指定模块中导入指定的内容
from package.b import funcb
funcb()

# 5。从指定包的子包中导入模块
from package.ps import c
c.funcc()

# 6。 从指定包的子包的指定模块中导入指定内容
from package.ps.d import funcd
funcd()
```

### 导入方式的分类

#### 绝对导入

```
# 绝对导入的方式会使用[搜索路径]去查找和导入指定的包或模块
import 模块
import 包
import 包.模块
from 模块 import 内容
from 包 import 模块
from 包.模块 import 内容
```

#### 相对导入

**注意：相对导入只能在非主程序的模块中使用，不需要直接运行的模块文件**

```
# 相对导入 
from .包名/模块名 import 模块/内容
from ..包名/模块名 import 模块/内容

. 代表当前
..代表上一级
```

#### 搜索路径

> 在导入模块或包时，程序查找的路径

```python
'''
主要的搜索路径
1. 当前导入模块的程序所在的文件
2. python的扩展目录中 C:/Users/username/AppData/local/.../Python37/lib
3. python解释器指定的其它 第三方模块位置 /lib/sitepackages
'''
# 在当前脚本中查看 包或模块 的 搜索路径
import sys
print(sys.path)
'''
[   
    '', 
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python37.zip', 
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7', 
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload',
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages'
 ]
'''

# 可以自己定义一个路径，加入到搜索路径中
sys.path.append('/Users/yc/Desktop')
```

### 单入口程序

> 单入口程序是指整个程序都是经过一个主程序文件在运行，其它程序都封装成了包或模块

```python
# 单入口文件是作为程序直接被运行的唯一文件，其它都是作为模块或包，被导入单入口中去执行
'''
ATM/
|---- main.py  # 当前程序的主入口文件，单入口文件,唯一直接运行的文件
|---- package/ # 主要程序模块包
|---- |----- __init__.py  # 包的初始化文件
|---- |----- View.py      # 视图函数模块
|---- |----- Controller.py# 控制器模块
|---- |----- Card.py      # 银行卡模块
|---- |----- User.py      # 用户模块
|---- databases/ # 数据存储文件夹
|---- |---- user.txt
|---- |---- user_id_card.txt

main是程序的主入口文件，会被直接作为主程序运行，所以main.py文件中必须使用 绝对导入 方式
'''
```



# 10、模块化编程

> 模块化编程指把程序进行封装(函数封装，面向对象，文件。。。)



### 函数

#### 什么是函数？

> function -> 函数，功能
>
> 函数就是一个具有特定功能的代码块

#### 函数的作用？

> 函数就是把代码进行封装，以提高代码的重用性，提高开发效率，并且降低了后期的维护成本

#### 函数的定义和使用

```python
# 定义函数【基本结构】
def 函数名([参数列表]):
    当前函数的具体功能的代码
    当前函数的具体功能的代码
    。。。。
    
# 函数封装完并不会执行，只是把函数定义了而已
# 如果想使用定义的函数，那么就需要用语法来进行函数的调用

# 函数的调用
函数名()
```

#### 函数的特征及注意事项

1. 函数定义后，不调用不执行
2. 不能在函数定义前调用函数
3. 函数的调用不受次数影响
4. 函数的命名要遵守命名规范
   + 字母数字下划线，不能以数字开头
   + 严格区分大小写，不能使用关键字
   + 命名最好有意义，且不要使用中文
5. 函数名不要冲突，冲突后会被覆盖



### 关于函数的参数

> 函数在定义时,可以在参数列表的位置定义形参
>
> 如果函数有形参,那么在函数调用时也需要给定参数
>
> 实参将值传递给形参的过程，本质上就是变量赋值操作

####  (1)函数参数概念及分类

    函数参数:调用时需要传递的数据.
    函数参数大类分为形参和实参:
    . 形参意思: 函数定义时的参数
    . 实参意思: 函数调用时的参数
    形实关系:函数调用时,形参和实参个数需要一一对应
    形参种类: 普通参数,默认参数,普通收集参数,命名关键字参数,关键字收集参数
    实参种类: 普通实参,关键字实参

#### (2)普通参数

（位置参数）普通的参数，接收实参传递的值

####  (3)默认参数：

> 位于普通参数后面，具有默认值的参数
>
> 语法：(x,y=2)   y就是默认参数

 #### (4)收集参数:

> 专门收集在函数调用时传递的多余的实参

```
1.普通收集参数:专门用于收集多余的普通参数,形成一个新的元组
	语法:参数前面加*	例:*args

2.关键字收集参数:用于专门收集多余关键字实参,形成一个新的字典
    语法:参数前面加**	例:**kwargs	
```

#### (5)命名关键字参数

> 定义时放在*号后面的参数,调用时强制必须传入指定参数名才能调用

```
语法:(a,*,x) x是命名关键字参数
如果函数参数中已经有了收集参数，那么收集参数后面的参数即为命名关键字参数
   语法:(*args,x,y)
```

#### (6)形参声明的位置顺序:

> 普通参数 -> 默认参数 -> 收集参数 -> 命名关键字参数 -> 关键字收集参数

```
def func(a,b,c=1,*args,d,**kw)
a,b为普通参数，c是默认参数，args是收集参数，d是命名关键字参数，kw是关键字收集参数

极少出现五种参数同时出现的情况
def func(a,b=2,*,c,d,**kw)
a为普通参数，b是默认参数，c，d是命名关键字参数 ，kw是关键字收集参数
```

  #### 所有参数的摆放问题

- 实参：普通实参在前，关键字参数在后
- 形参：
  - 关键字收集参数一定在最后出现
  - 收集参数推荐在普通参数之后使用
- 推荐顺序：普通形参,收集参数,关键字收集参数

### 函数返回值

> 一个函数除来可以完成一定功能之外，还可以按需要返回一些内容
>
> 函数中使用 return 关键字来指定返回数据，可以返回任意类型的数据
>
> 函数的返回值，会把数据返回到调用处，可以使用变量接收，或其它处理

```
函数可以分为两类
    1。执行过程函数： 函数体内完成一定的功能既可，没有返回值
    2。具有返回值的函数： 函数体内完成一定的功能，并且返回一个结果到函数调用处
```

####  return返回值的特征

+ 函数中可以使用 return 进行数据的返回
+ 可以使用return 返回 任意内容或数据
+ return 会把返回值，返回到函数调用出
+ return 意味着函数的结束，return之后的代码不在执行
+ 如果在函数中没有使用return  或者 return后面没有任何内容，那么默认返回 None

```python
# 假设有这样一个需求，定义一个函数，完成两个数的计算，并把结果输出
# def jia(n1,n2):
#     res = n1+n2
#     print(res)
# jia(2,5)

# 需求改变，定义一个函数，完成两个数的计算，并把结果返回
def jia(n1,n2):
    res = n1+n2
    return res

r = jia(2,4)
print(r)
```

### 变量作用域

> 作用域就是当前起作用，可用的范围区域
>
> 变量的有效范围

全局变量：在函数内外都可以使用的变量

局部变量：在函数内部可以使用的变量

```
局部变量
    函数内定义的变量，局部变量，在函数外不能使用

全局变量
    在函数内部使用 global 直接定义的变量，就是全局变量，函数内外都可以使用
    在函数外定义的变量，在函数内使用 global 关键字进行声明，那么也是全局变量

globals()  获取全局数据
locals()  获取当前作用域的数据

    在函数外定义的变量，函数可以访问，但是不能更改

数据类型的分类：
    可变数据类型：在函数外定义的变量，在函数可以使用，
        列表和字典
    不可变数据类型：在函数外定义的变量，在函数内只能访问，不能使用其它操作
```

#### 不光变量有作用域，函数一样也有相同的作用域

```python
def outer():
    print('this is outer function...')
    # 在函数内定义的函数，称为 局部函数，函数外无法使用
    def inner():
        print('this is inner function...')
    inner()

outer()
# inner()
```


### nonlocal

> 在内函数中如何使用上一层函数中的局部变量？
> 在内函数中如果想使用外层函数的变量，那么需要使用 nonlocal 关键字 引用
> 可以引用上一层函数中定义的局部变量，但依然不能提升为全局变量

```python
# 定义一个外层函数
def outer():
    # 外函数的局部变量
    num = 10
    # 内函数，局部函数，在函数的内部定义的函数
    def inner():
        # nonlocal 关键字在局部函数中使用，
        nonlocal num # 可以引用上一层函数中定义的局部变量，但依然不能提升为全局变量
        num += 1
        print(num)
    inner()


outer()
# print(num)
```


#### 关于函数的文档

```python
def outer():
    '''
    这里是让你些当前函数的文档说明的。
    需要说明当前函数的作用，
    如果当前函数还有行参，那么也需要对行参进行一一说明
    name： 这个是一个name参数，有什么作用。。。
    age ： 这个表示当前的一个年龄
    :return:  此处说明当前函数的返回值。。。
    '''

print(globals())
print(__name__) # 获取当前脚本的文件名，
print(__doc__) # 获取当前脚本的说明文档
# print(outer.__doc__) # 获取当前函数的说明文档
'''
魔术变量
__name__  ==> 当前脚本如果作为主程序，那么值是 __main__,如果是当做一个模块，在另外一个脚本中引用去使用，那么值就是当前文件的名字
__doc__   ==> 当前脚本的文档说明 在当前脚本当中的第一个 三引号注释就是当前脚本的说明文档


{
    '__name__': '__main__', 
    '__doc__': '\n在内函数中如果想使用外层函数的变', 
    '__package__': None,
     '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x110444350>, 
     '__spec__': None, 
     '__annotations__': {}, 
     '__builtins__': <module 'builtins' (built-in)>, 
     '__file__': '/Users/yc/Desktop/code/8.nonlocal关键字.py', 
     '__cached__': None, 'outer': <function outer at 0x1104938c0>
}

'''


```



# 12、内置函数

> 内置函数就是在系统安装完python解释器时，由python解释器给提供好的函数



### [`range()`](https://docs.python.org/zh-cn/3.7/library/stdtypes.html#range) 函数

> 如果你确实需要遍历一个数字序列，内置函数 [`range()`](https://docs.python.org/zh-cn/3.7/library/stdtypes.html#range) 会派上用场。它生成算术级数

```
range()函数
功能：能够生成一个指定的数字序列
参数：
    start : 开始的值 ，默认值为0
    stop  ： 结束的值
    [, step]： 可选，步进值 默认值为1
返回值： 可迭代的对象，数字序列
```

使用案例：

```python
#range函数的使用方式
# 只写一个参数，就是从零开始到10之前，9
# res = range(11)

# 两个参数时，第一个参数是开始的值，第二个参数是结束的值（在结束值之前）
# res = range(5,10)

# 三个参数， 参数1是开始值，参数2是结束值，参数三是步进值
# res = range(1,10,3)

# 获取一个倒叙的数字序列
# res = range(10,0,-1)
# res = range(10,0,-2)

res = range(-10,-20,-1)
res = range(-20,-10)
res = range(-10,10)
print(list(res))
```

提取range()函数返回的数字序列的方法：

```python
# 获取range函数返回的数字序列的方法
# res = range(10)
# 1。转为list列表数据
# print(list(res))

# 2。通过 for循环 进行遍历
# for i in res:
#     print(i)

# 3。转为迭代器，使用next函数调用
# res = iter(res)
# print(next(res))
# print(next(res))
```

### zip() 函数

```
zip()
功能：zip 函数是可以接受多个可迭代的对象，然后把每个可迭代对象中的第i个元素组合在一起，形成一个新的迭代器
参数：*iterables，任意个的 可迭代对象
返回值： 返回一个元组的迭代器
```

示例：

```python
var1 = '1234'
var2 = ['a','b','c']
var3 = ('A','B','C','D')
# 调用zip函数，组成新的元组迭代器
res = zip(var1,var2,var3)
# print(res,type(res))

for i in res:
    print(i)
'''
('1', 'a', 'A')
('2', 'b', 'B')
('3', 'c', 'C')
('4', 'd', 'D')
'''


# zip() 与 * 运算符相结合可以用来拆解一个列表:
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
print(list(zipped))

print(zip(x, y)) # 迭代器对象，
print(*zip(x, y))# 组合好的多个元组数据
```

### 其它内置函数

### 数据类型转换相关内置函数

+ int() 将其它类型数据转为整型
+ float() 转为浮点类型
+ bool() 转为布尔类型
+ complex() 转为复数
+ str() 转为字符串类型
+ list 转为列表类型
+ tuple 转为元组类型
+ dict 转为字典类型
+ set 转为集合类型

### 变量相关函数

+ id()    获取当前数据的ID标识
+ type()  获取当前数据的类型字符串
+ print() 数据的打印
+ input() 获取输入的数据
+ isinstance() 检测是否为指定的数据类型

### 数学相关函数

```python
# 数学相关函数

# 获取一个数的绝对值
# print(abs(-99.99))

# 求和 从 start 开始自左向右对 iterable 中的项求和并返回总计值
# print(sum([1,2,3]))

# 获取最大值
# print(max([1,2,3]))
# print(max(99,12,45))

# 获取最小值
# print(min([2,1,6,-9]))
# print(min(6,7,1,0,-2))

# 幂运算  返回 x 的 y 次幂
# print(pow(2,3))

# 四舍五入
# r = round(3.1415926)
# r = round(3.1415926,2) # 小数点保留几位

# r = round(4.5) # 奇进偶退  1.5 = 2 2.5=2,3.5=4,4.5=4
# print(r)
```

### 进制相关函数

```python
# bin() 将数值类型转为二进制
# print(bin(123)) # 0b1111011

# int() 将二进制转为整型
# print(int(0b1111011)) #1 23

# oct() 转为八进制数 01234567
# print(oct(123)) # 0o173

# hex() 转为十六进制数 0123456789abcdef
# print(hex(123)) # 0x7b
```

### Ascii码及字符集

+ Ascii 共计 128个字符，更新于 1986年 主要用于显示现代英语和其他西欧语言。
+ GB2312-80 是 1980 年制定的中国汉字编码国家标准。共收录 7445 个字符，其中汉字 6763 个。
+ GBK 于1995年制定 收录了 21003 个汉字。GBK向下与 GB 2312 编码兼容，
+ GBK18030 2001年的1月正式强制执行，是我国制订的以汉字为主并包含多种我国少数民族文字（如藏、蒙古、傣、彝、朝鲜、维吾尔文等）的超大型中文编码字符集强制性标准，其中收入汉字70000余
+ Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。
  + 它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。
  + UTF-8 以字节为单位对Unicode进行编码。



```python
# 将字符转为 ascii
r = ord('a')
print(r)

# 将ascii转为字符
r = chr(65)
print(r)
```

### 高阶函数



### sorted(iterable,[reverse,key])

```
sorted()
运行原理：
    把可迭代数据里面的元素，一个一个的取出来，放到key这个函数中进行处理，
    并按照函数中return的结果进行排序，返回一个新的列表
功能： 排序
参数：
    iterable 可迭代的数据 （容器类型数据，range数据序列，迭代器）
    reverse  可选，是否反转，默认为False，不反转， True反转
    key      可选， 函数，可以是自定义函数，也可以是内置函数
返回值： 排序后的结果
```

示例：

```python
arr = [3,7,1,-9,20,10]
# 默认按照从小到大的方式进行排序
# res = sorted(arr)  # [-9, 1, 3, 7, 10, 20]

# 可以按照从大到小的方式进行排序
# res = sorted(arr,reverse=True)  # [20, 10, 7, 3, 1, -9]

# 使用abs这个函数(求绝对值）作为sorted的key关键字参数使用
res = sorted(arr,key=abs)
# print(res)

# 使用自定义函数
# def func(num):
#     print(num,num % 2)
#     return num % 2
#
# arr = [3,2,4,6,5,7,9]
#
# # 在sorted函数中使用自定义函数对数据进行处理
# res = sorted(arr,key=func)
# print(res)

## 优化版
arr = [3,2,4,6,5,7,9]
res = sorted(arr,key=lambda x:x%2)
print(res)
```



### map(func, *iterables)

> 对传入的可迭代数据中的每个元素进行处理，返回一个新的迭代器

```
map(func, *iterables)
功能： 对传入的可迭代数据中的每个元素放入到函数中进行处理，返回一个新的迭代器
参数：
    func 函数  自定义函数|内置函数
    iterables：可迭代的数据
返回值：迭代器
```

示例：

```python
# （1）把一个字符串数字的列表转为 整型的数字列表
# ['1','2','3','4']  # ==> [1,2,3,4]
# 普通的处理方法
# varlist = ['1','2','3','4']  # ==> [1,2,3,4]
# newlist = []
# for i in varlist:
#     newlist.append(int(i))
# print(newlist)

# 使用map函数进行处理
# varlist = ['1','2','3','4']
# res = map(int,varlist) # <map object at 0x104ea8890>
# print(list(res))

# (2) [1,2,3,4] ==> [1,4,9,16]

# 普通方法
# varlist = [1,2,3,4]
# newlist = []
# for i in varlist:
#     res = i ** 2
#     newlist.append(res)
# print(newlist)

# 使用map函数处理这个数据
varlist = [1,2,3,4]
# def myfunc(x):
#     return x ** 2
# res = map(myfunc,varlist)
# print(res,list(res))

# 优化版
# res = map(lambda x:x**2,varlist)
# print(res,list(res))


# 练习作业
# (3) ['a','b','c','d'] ==> [65,66,67,68]
```



### reduce(func,iterable)

```
reduce(func,iterable)
功能：
    每一次从 iterable 拿出两个元素，放入到func函数中进行处理，得出一个计算结果，
    然后把这个计算结果和iterable中的第三个元素，放入到func函数中继续运算，
    得出的结果和之后的第四个元素，加入到func函数中进行处理，以此类推，直到最后的元素都参与了运算
参数：
    func： 内置函数或自定义函数
    iterable： 可迭代的数据
返回值：最终的运算处理结果
注意： 使用 reduce函数时，需要导入 from functools import reduce
```

示例：

```python
from functools import reduce

### (1) [5,2,1,1] ==> 5211

# 普通方法
# varlist = [5,2,1,1]
# res = ''
# for i in varlist:
#     res += str(i)
# res = int(res)
# print(res,type(res))
'''
5 2 1 1
5 * 10 + 2 == 52
52 * 10 + 1 == 521
521 * 10 + 1 == 5211
'''

# 使用 reduce完成
# def myfunc(x,y):
#     return x*10+y
# varlist = [5,2,1,1]
# # 调用函数
# res = reduce(myfunc,varlist)
# print(res,type(res))

# （2） 把字符串的 '456' ==> 456
#  要求不能使用int方法进行类型的转换时，如何解决上面的问题

# 定义函数，给定一个字符串的数字，返回一个整型的数字
def myfunc(s):
    vardict = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9}
    return vardict[s]

# 1.先使用 map函数，把数字字符串，转为整型的数字
iter1 = map(myfunc,'456')

# 2. 把数字列表中的值，使用lambda进行二次处理
iter2 = reduce(lambda x,y:x*10+y,iter1)
print(iter2)
```



### filter(func,iterable)

```
filter(func,iterable)
功能： 过滤数据，把 iterable 中的每个元素拿到 func 函数中进行处理，
        如果函数返回True则保留这个数据，返回False则丢弃这个数据
参数：
    func  自定义函数
    itereble： 可迭代的数据
返回值：保留下来的数据组成的 迭代器
```

示例：

```python
# 要求 保留所有的偶数，丢弃所有的奇数
varlist = [1,2,3,4,5,6,7,8,9]

# 普通方法实现
# newlist = []
# for i in varlist:
#     if i % 2 == 0:
#         newlist.append(i)
# print(newlist)

# 使用 filter 进行处理

# 定义一个函数，判断当前这个函数是否为偶数，偶数返回True，奇数返回False
# def myfunc(n):
#     if n % 2 == 0:
#         return True
#     else:
#         return False
#
# # 调用 过滤器 函数进行处理
# it = filter(myfunc,varlist)
# print(it,list(it))

# 优化版
it = filter(lambda n:True if n % 2 == 0 else False,varlist)
print(it,list(it))
```

# 11、高阶函数

### 递归函数

> 递归函数就是定义了一个函数，然后在函数内，自己调用了自己这个函数
> 递归函数内必须要有结束，不然就会一只调用下去，直到调用的层数越来越多，栈溢出
> 递归函数是一层一层的进入，再一层一层的返回

#### 初步认识递归函数

```python
# 初步认识 递归函数  3 2 1 0
def digui(num):
    print(num) # 3 2 1 0
    # 检测当前的值是否到了零
    if num > 0:
        # 调用函数本身
        digui(num-1)
    print(num) # 0 1 2 3

digui(3)

'''
解析当前递归函数的执行过程：
digui(3) ==> 3 
    digui(3-1) ==> 2
        digui(2-1) ==> 1
            digui(1-1) ==> 0
            digui(0) ==> 0
        digui(1) ==> 1
    gidui(2) ==>2
digui(3) ==> 3
'''
```

### 回调函数

> 函数中的参数可以是任意类型的，那参数能不能是一个函数呢？
>
> 如果在一个函数中要求传递的参数是一个函数作为参数，并且在函数中使用了传递进来的函数，那么这个函数我们就可以称为是一个回调函数

```python
# 定义一个函数,函数中的一个参数要求是另一个函数
# 带有回调函数参数的函数
# def func(f):
    # print(f,type(f))
    # 并且在函数中调用了传递进来的行参函数
    # f()


# 回调函数
# def love():
#     print('123')
#
# func(love)
```



### 闭包函数

> 既然可以把函数作为一个行参进行传递，作为回调函数，那么如果在一个函数中，返回了一个函数呢？
>
> 在一个函数内返回了一个内函数， 并且这个返回的内函数还使用了外函数中局部变量，这就是闭包函数

**特点：**

1. 在外函数中定义了局部变量，并且在内部函数中使用了这个局部变量
2. 在外函数中返回了内函数，返回的内函数就是闭包函数
3. ⚠主要在于保护了外函数中的局部变量，既可以被使用，又不会被破坏
4. 检测一个函数是否为闭包函数，可以使用 `函数名.__closure__ `如果是闭包函数返回 cell

```python
# 定义一个函数
def person():
    money = 0  # 函数中定义了一个局部变量
    # 工作 定义的内函数
    def work():
        nonlocal money   # 在内函数中使用了外函数的临时变量
        money += 100
        print(money)
    # 在外函数中返回了内函数，这个内函数就是闭包函数
    return work

res = person() # return work  res = work
res() # res() == work()
res()
res()
res()
# 此时 就不能够在全局中对money这个局部变量进行任何操作了，
# 闭包的作用：保护了函数中的变量不受外部的影响，但是又能够不影响使用
```



### 匿名函数  lambda 表达式

> 匿名函数的意思就是说可以不使用def定义，并且这个函数也有没有名字
>
> 在python中可以使用lambda表达式来定义匿名函数
>
> 注意：lambda表达式仅仅是一个表达式，不是一个代码块，所以lambda又称为一行代码的函数
>
> lambda表达式也有行参，并且不能访问除了自己的行参之外的任何数据包括全局变量

```python
'''
语法：
lambda [参数列表]:返回值
'''

# 封装一个函数做加法运算
# 普通函数
def jia(x,y):
    return x+y

# print(jia(2,3))

# 改成lambda表达式来封装
res = lambda x,y:x+y
# print(res(4,4))

# 带有分支结构的lambda 表达式
#  lambda 参数列表: 真区间 if 表达式判断 else 假区间
res = lambda sex:"很man" if sex=='男' else "很nice"
print(res('女'))
```



### 迭代器

> 迭代器是python中最具特色的功能之一，是访问集合元素的一种方式
>
> 迭代器是一个可以记住访问遍历的位置的对象
>
> 从集合的第一个元素开始访问，直到集合中的所有元素被访问完毕
>
> 迭代器只能从前往后一个一个的便利，不能后退
>
> 能被next()函数调用，并不断返回下一个值的对象称为迭代器（Iterator 迭代器对象）


#### iter()                        

> 功能：把可迭代的对象，转为一个迭代器对象          
> 参数：可迭代的对象 （str，list，tuple，dict
> 返回值： 迭代器对象                    
> 注意：迭代器一定是一个可以迭代的对象，但是可迭代对象不一定是迭代器 

#### next()

> next()函数可以去调用迭代器，并返回迭代器中的下一个数据

#### 迭代器的取值方案                                           

1. next() 调用一次获取一次，直到数据被取完                   
2. list() 使用list函数直接取出迭代器中的所有数据              
3. for    使用for循环遍历迭代器的数据                    

##### 迭代器取值的特点，取出一个少一个，直到都取完，最后再获取就会报错                 


#### 检测迭代器和可迭代对象的方法  

```python
from collections.abc import Iterator,Iterable                   
                                                                
varstr = '123456'                                               
res = iter(varstr)                                              
                                                                
# type() 函数返回当前数据的类型，                                           
# isinstance() 检测一个数据是不是一个指定的类型                                 
r1 = isinstance(varstr,Iterable) # True 可迭代对象                   
r2 = isinstance(varstr,Iterator) # False 不是一个迭代器                
r3 = isinstance(res,Iterable) # True 可迭代对象                      
r4 = isinstance(res,Iterator) # True 是一个迭代器                     
print(r1,r2)                                                    
print(r3,r4)         
# 迭代器一定是一个可迭代的对象，可迭代对象不一定是迭代器                                           
```



# 13、File(文件)操作

> 针对磁盘中的文件的读写。文件I/O  I 输入(input) O输出（Output）
>
> 文件操作步骤：1.打开文件    2.读写文件  3.关闭文件

#### 写入文件的操作：（把大象装进冰箱）

1. 打开文件 open()   ==> 打开冰箱
2. 写入内容 write()   ==> 把大象装进冰箱
3. 关闭文件 close()   ==> 关闭冰箱门

#### 读取文件的操作：（把大象从冰箱中取出）

1. 打开文件 open()  ==> 打开冰箱门
2. 读取内容 read()   ==> 把大象拿出来
3. 关闭文件 close()  ==> 关闭冰箱门

# 14、内置模块-时间模块

### time 时间模块

```python
import time

'''
概念：
    1。 时间戳： 1574905882.6581771 表示从1970年1月1日0时0分0秒到现在的一个秒数，目前可以计算到2038年
    2。 时间字符串： Thu Nov 28 09:54:08 2019  
    3。 时间元组： time.struct_time(tm_year=2019, tm_mon=11, tm_mday=28, tm_hour=9, tm_min=55, tm_sec=32, tm_wday=3, tm_yday=332, tm_isdst=0)

'''

# *** 1. 获取当前系统的时间戳
res = time.time()

# 2. 获取当前系统时间，时间字符串
res = time.ctime()

# 3. 获取当前系统时间， 时间元组
res = time.localtime()

# 4. 以上时间字符串和时间元组可以通过指定的时间戳来获取
t = 1564000082.6581771
res = time.ctime(t)
res = time.localtime()

# 5. 使用localtime方法获取的时间元组，如何格式化成为 xxxx年xx月xx日 时：分：秒  星期几
# print(f'{res.tm_year}年{res.tm_mon}月{res.tm_mday}日 {res.tm_hour}：{res.tm_min}：{res.tm_sec} 星期{res.tm_wday+1}')


# *** 6. strftime() 格式化时间 年-月-日  时：分：秒 星期几
res = time.strftime('%Y-%m-%d %H:%M:%S %w')


# *** 7。 sleep(秒) 在给定的秒数内暂停调用线程的执行。该参数可以是浮点数，以指示更精确的睡眠时间。
# print(time.strftime('%Y-%m-%d %H:%M:%S %w'))
# time.sleep(3)
# print(time.strftime('%Y-%m-%d %H:%M:%S %w'))

# 、计算程序的运行时间
# time.perf_counter()

# 100万次的字符串比较 需要执行的时间

start = time.perf_counter()
for i in range(1000000):
    if 'abc' > 'acd':
        pass
end = time.perf_counter()
print(end-start) # 0.14171751

# 
start = time.perf_counter()
for i in range(1000000):
    if 103 > 100 :
        pass
end = time.perf_counter()
print(end-start) # 0.164985942
```

### calendar 日历模块



### 文件操作相关函数

####  open() 打开文件

> 格式： open(文件的路径，打开的方式，[字符集])



#### Seek() 设置文件指针的位置

> ```python
> fp.seek(0)  # 把文件指针设置到文件的开头位置
> fp.seek(10)   # 设置文件指针的位置
> fp.seek(0,2)  # 0,2是把文件指定设置在文件的末尾
> ```



#### write() 写入内容

> 格式：文件对象.write(字符串)

#### writelines() 写入容器类型数据

> 格式：文件对象.write(容器类型数据)
>
> 注意：容器类型数据中的元素也必须是可写入的字符串类型



#### read() 读取内容

> 格式：文件对象.read()    从当前指针位置读取到最后
>
> 格式：文件对象.read(读取的字节数)  可以读取指定长度的字符 



#### readline() 读取一行

>格式： 文件对象.readline() 一次读取一行
>
>格式： 文件对象.readline(字节数) 一次读取一行中指定长度的字节



#### readlines() 读取所有行

> 格式： 文件对象.readlines() 读取所有行，每一行作为一个元素，返回了一个列表
>
> 格式：文件对象.readlines(6) 按照行进行读取，可以设置读取的字节数，设置的字节数不足一行按一行算



#### close() 关闭文件

> 格式：文件对象.close()   关闭打开的文件





#### 文件操作的高级便捷写法

```python
# 文件操作的 高级写法
'''
with open(文件路径，打开模式) as 变量：
    变量.操作()
'''

with open('./1.txt','r+',encoding='utf-8') as fp:
    res = fp.read()
    print(res)
```



#### 文件的路径：

```python
文件路径  路径 url  统一资源定位符
    
#相对路径： 就像给别人指路一样： 在某某大厦的对面。。。
    针对文件的相对路径的表示，从当前目录开始计算
     1.txt ==>  具体文件前没有任何表示时，默认为当前目录 和 ./1.txt 是一个位置
     ./1.txt  ==> ./ 代表当前目录中的 1.txt
     ../1.txt ==> ../ 代表当前目录中的 上一级目录中的1.txt
#绝对路径： 就像买东西写收货地址一样： 北京市海淀区中关村大街128号xxx小区，xxx号楼xx单元xx室
    windows：  c:/users/appdata/1.txt
    Linux： /user/home/yc/1.txt
```

#### 打开的模式：

```python
#一，基础模式:  w  r  x  a
  w w模式  write 写入模式
      1。 文件如果不存在，则创建这个文件
      2。 文件如果存在，则打开这个文件，并且清空文件内容
      3。 文件打开后，文件的指针在文件的最前面

  r r模式： read  读取模式
      1。 如果文件不存在，则报错
      2。 文件如果存在，则打开文件
      3。 文件指针在文件的最前面

  x x模式： xor 异或模式
      1。文件不存在，则创建这个文件
      2。文件已存在，则报错（防止覆盖）
      3。文件的指针在文件的最前面

  a a模式： append 追加模式
      1。文件不存在，则创建文件
      2。文件如果存在，则打开文件 （和w模式的区别在于。a模式打开文件后不会清空）
      3。文件指针在当前文件的最后

#二，扩展模式：
            b b模式  bytes   二进制
            + +模式  plus    增强模式（可读可写）
#三，文件操作模式的组合：
            w,r,a,x
            wb,rb,ab,xb,
            w+,r+,a+,x+
            wb+,rb+,ab+,xb+
```

# 15、Re 正则表达式

> 正则表达式，就是使用字符，转义字符和特殊字符组成一个规则，
> 使用这个规则对文本的内容完成一个搜索或匹配或替换的功能、

### 正则表达式的组成

```
普通字符： 大小写字母，数字，符合。。。
转义字符：\w \W \d \D \s \S ...
特殊字符：.  * ? + ^ $ [] {} ()
匹配模式：I U。。。
```

示例：

```python
# 使用正则表达式进行匹配的 基本语法
import re
# 定义字符串
vars = 'iloveyou521tosimida'
# 定义正则表达式
reg = 'love'
# 调用正则函数方法
res = re.findall(reg,vars)
print(res)
```



### 正则表达式规则定义详解



#### 普通字符

```python
# 正则表达式的规则定义
import re

# 普通字符

# vars = 'iloveyou'
# reg = 'love'
# res = re.search(reg,vars).group()
# print(res)
```

#### 转义字符

```python
# 转义字符 \w \W \d \D \s \S ...
varstr = 'a2$_ilove5	21you'

reg = '\w' # 代表 单个 字母、数字、下划线
reg = '\W' # 代表 单个的 非 字母、数字、下划线
reg = '\d' # 代表 单个的 数字
reg = '\D' # 代表 单个的 非数字
reg = '\s' # 代表 单个的 空格符或制表符
reg = '\S' # 代表 单个的 非 空格符或制表符
reg = '\w\w\w\w\d' # 组合使用
```

#### 特殊字符

```python
# 特殊字符 . * + ? {} [] () ^ $
varstr = 'hello WORLD  iloveyou5211imissyou'

reg = '.'    # . 点 代表 单个的 任意字符 除了换行符之外
reg = '\w*'  # * 代表匹配次数  任意次数
reg = '\w+'  # + 代表匹配次数  至少要求匹配一次
reg = '\w+?' # ? 拒绝贪婪，就是前面的匹配规则只要达成则返回
reg = '\w*?'
reg = '\w{5}' # {} 代表匹配次数，{4} 一个数字时，表示必须匹配的次数
reg = '\w{2,4}' # {} 代表匹配次数，{2,5} 两个数字时，表示必须匹配的区间次数
reg = '[A-Z,a-z,0-9,_]' # [] 代表字符的范围 [A-Z,a-z,0-9,_] == \w
reg = '\w+(\d{4})(\w+)'  # () 代表子组，括号中的表达式首先作为整个正则的一部分，另外会把符合小括号中的内容单独提取一份

varstr = '17610105211'
# 定义一个匹配手机号的正则表达式
reg = '^1\d{10}$' # ^ 代表开头  $ 代表结尾

# res = re.search(reg,varstr)
# print(res.group())
# print(res.groups())

'''
*号的特点： 
    如果使用*号，那么在匹配的开始处如果符合要求，
    则按照规则一直向后匹配，直到不符合匹配规则结束并把前面符合的数据返回
    
    如果在匹配的开始处就不符合要求，则直接返回，匹配到的次数为0
'''
```

#### 正则模式

```python
# 正则模式 re.I 不区分大小写
vars = 'iLOVEyou'

reg = '[a-z]{5,10}'
res = re.search(reg,vars,re.I)
print(res)
```



### re模块相关函数

#### re.match() 函数

+  从头开始匹配
+  要么第一个就符合要求，要么不符合
+  匹配成功则返回Match对象，否则返回None
+  可以使用group()方法获取返回的数据
+  可以使用span()方法获取匹配的数据的下标区间

#### re.search() 函数

    + 从字符串开头到结尾进行搜索式匹配
    + 匹配成功则返回Match对象，否则返回None
    + 可以使用group()方法获取返回的数据
    + 可以使用span()方法获取匹配的数据的下标区间

##### search() 和 match() 方法的区别：

```
match()方法是从字符串的开头进行匹配，如果开始就不符合正则的要求，则匹配失败，返回None
search()方法是从字符串的开始位置一直搜索到字符串的最后，如果在整个字符串中都没有匹配到，则失败，返回None
```

#### re.findall()

+ 按照正则表达式的规则在字符中匹配所有符合规则的元素，结果返回一个列表，如果没有找到则返回空列表

#### re.finditer()

+ 按照正则表达式的规则在字符中匹配所有符合规则的元素，返回一个迭代器

#### re.sub() 搜索替换

+ 按照正则表达式的规则，在字符串中找到需要 被替换的字符串，完成一个替换
+ 参数：
  + pattern： 正则表达式的规则，匹配需要被替换的字符串
  + repl：    替换后的字符串
  + string：  被替换的原始字符串

#### compile()

​    可以直接将正则表达式定义为 正则对象，使用正则对象直接操作

示例：

```python
import re

# 定义字符串
varstr = 'iloveyou521tosimida511'

# 正则表达式
reg = '\d{3}'
# 函数调用
# res = re.findall(reg,varstr)
# res = re.finditer(reg,varstr)
# print(list(res))

# 找到数字，替换成其它
# res = re.sub(reg,'AAA',varstr)
# print(res)

# 直接定义正则表达式对象
reg = re.compile('\d{3}')
# 直接使用创建的正则对象，去调用对应的方法或函数
res = reg.findall(string=varstr)
# print(res)
```

### 练习题

```
# 练习题：
# 1。定义一个正则表达式，来验证邮箱是否正确
# 2。完善 手机号的 正则表达式
# 3。定义一个 匹配 IP 的正则表达式 192.168.1.1  255.255.255.0
```





# 17、第三方库的管理和虚拟环境



## 第三方库的管理

> python中比较牛逼的地方就是由大量的第三方库提供给你使用。

#### 第三方库的管理网站 https://pypi.org/

#### 如何安装第三方库

####  pip

> pip就是python的包管理工具，解决了包直接的依赖关系。可以方便的管理第三方库(包).
>
> 类似于PHP中Composer，或者Nodejs中的npm，或者Linux中的yum。

### 如何使用pip

`pip install 包名（库名）`

注意：如果有多个python环境的情况下，可能需要使用pip3

例如安装pymysql这个库

`pip install pymysql`

### 安装指定版本的包

`pip install 包名==版本`

### 搜索已经安装的包

`pip show 包名`

### 查看安装的所有包

`pip list` 

### 更换pip的镜像源

```
PIP 更换国内安装源

pip国内的一些镜像
  阿里云 http://mirrors.aliyun.com/pypi/simple/ 
  中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 
  豆瓣(douban) http://pypi.douban.com/simple/ 
  清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 
  中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/

修改源方法：

临时使用： 
可以在使用pip的时候在后面加上-i参数，指定pip源 
pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple

永久修改： 
linux: 
修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：

[global]
timeout = 6000
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn


windows: 
直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，在pip 目录下新建文件pip.ini，内容如下

或者按照网友的建议：win+R 打开用户目录%HOMEPATH%，在此目录下创建 pip 文件夹，在 pip 目录下创建 pip.ini 文件, 内容如下

 
[global]
timeout = 6000
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn

```

## 虚拟环境

> 虚拟环境就是在当前的系统环境中，去配置另外一个python的运行环境，是可以创建多个不同的虚拟环境。
>
> python的虚拟环境相互独立，互不影响。

+ 虚拟环境中可以在没有权限的情况下安装新的库（Linux系统中可能会出现的问题）
+ 不同的应用可以使用不同的库或不同的版本。
+ 虚拟环境中的库升级也不影响其它环境
+ 虚拟环境可以作为一个项目的专有环境。在需要部署时，一键导出项目的所需要的包

### 如何去使用python的虚拟环境

1。在pycharm中可以直接创建虚拟环境

#### 2。自己安装独立的虚拟环境

1. #### 创建虚拟环境

`python -m venv 虚拟环境名`

2. #### 进入虚拟环境，激活虚拟环境

   + linux

   ```shell
   # 使用 source 命令 去执行 v1/bin/ 目录下的 activate
   localhost:code yc$ source v1/bin/activate
   (v1) localhost:code yc$ 
   ```

   + windows

   ```shell
   # windows系统需要 进入 v1/Scripts/ 这个目录
   cd v1/Scripts/ 
   # 运行 activate.bat 文件
   activate.bat
   (v1) F:\code>
   ```

3. #### 接下来就可以在虚拟环境中安装一些包

`pip install pymysql`

4. #### 查看是否安装了某个包

`pip show pymysql` 如果安装过则能显示信息。

5. #### 退出虚拟环境

   + linux :  deactivate
   + Windows： 直接ctrl+c

6. #### 导出当前环境中所有安装过的包

```shell
# 查看所有安装的包
pip list
'''
Package      Version
------------ -------
Click        7.0    
Flask        1.1.1  
itsdangerous 1.1.0  
Jinja2       2.10.3 
MarkupSafe   1.1.1  
pip          19.0.3 
PyMySQL      0.9.3  
setuptools   40.8.0 
Werkzeug     0.16.0 
'''

# 导出所有包到文件
pip freeze > ./requirements.txt
```

7. #### 删除环境

退出虚拟环境后，直接删除虚拟环境文件夹即可



# 18、面向对象-OOP

> 面向对象编程——Object Oriented Programming，简称`OOP`，是一种**以对象为中心**的程序设计思想。
>
> 面向过程编程——Procedure Oriented Programming，简称`POP`，是一种**以过程为中心**的程序设计思想。



## 理解面向过程与面向对象思想

大家先思考一个问题：把大象装进冰箱，需要几步？

小品给出的答案：三步

第一步：打开冰箱门

第二步：把大象装进去

第三步：关上冰箱门



##### 用面向过程去理解

> 上面给出的答案就是面向过程的，遇到问题后，分析解决问题的步骤，然后一步步去实现

##### 用面向对象去理解

> 是通过分析问题中需要的抽象模型，然后更具需要的功能分别去创建模型对象，最终由模型对象来完成程序

首先面向对象要解决这个问题，需要先建立出抽象模型，比如：打开冰箱门和关闭冰箱门，这都属于一个冰箱的功能，大象走进去，这就是大象的功能。到此时我们就出现了两个抽象模型，一个是冰箱，一个是大象。

冰箱具有 打开和关闭的功能，大象具有走路的能力。

分析到这里，就是面向对象的思想，具体完成的话，就是去创建冰箱和大象这两个对象，最终完成这个程序

冰箱对象-开门，大象对象-走进冰箱，冰箱对象-关门



再思考一个问题，想吃清蒸鱼怎么办？

面向过程：

	1. 买鱼，买料
	2. 杀鱼和清理，并且腌制
	3. 放锅烧水
	4. 把鱼放进去，开始蒸
	5. 十分钟后开盖，把鱼端出来，浇汁

面向过程中想完成这个愿望，需要一步一步的去执行。

面向对象：

​	需要一个对象：大厨

​	告诉大厨，我想吃清蒸鱼

面向对象就是调用对象去解决问题，具体的对象如何去解决呢？

大厨这个对象肯定也是一步步完成。但是对于我来说，就是调用了对象。而对象去完成这个过程。

当然了最终面向对象中是有面向过程的体现的。





### 面向过程和面向对象的区别和优缺点？



#### 一，面向过程

>  面向过程的核心是过程，过程就是指解决问题的步骤。

优缺点：

+ 优点： 将负责的问题流程化，进而实现简答化
+ 缺点：扩展性差（更新，维护，迭代）

总结：在去完成一些简单的程序时，可以使用面向过程去解决。但是如果有复杂的程序或任务，而且需要不断的进行迭代和维护，那么肯定是优先选择面向对象的编程思想



#### 二，面向对象

> 面向对象的核心是对象，是一个特征和功能的综合体

优缺点：

+ 优点：可扩展性高
+ 缺点：编程复杂度相对面向过程高一些。指的是计算机在执行面向对象的程序时的性能表现



### 后面如何去学习面向对象编程？

1. 理解面向对象编程的思想
2. 学习面向对象编程的语法



### 认识类与对象

类：类是对象的一个抽象的概念

对象（实例）：对象就是由类的创建的实例

类和对象的关系就是 模具与铸件的关系

1. 类是由对象总结而来的，总结的这个过程叫做抽象
2. 对象是由类具体实施出来的，这个过程叫做实例化

如果你现在有点迷糊，那你想一想，

+ 水果是一个对象还是一个类？
+ 汽车是一个对象还是一个类？
+ 手机是一个对象还是一个类？

再来想一个问题，我现在给大家上课，用的是一个笔记本电脑，

请问我当前正在使用的这个笔记本电脑是一个对象还是一个类？

笔记本电脑特征：金属外壳，优美的外观

笔记本电脑功能：给大家制作课程，编辑代码，听音乐。。。



## 面向对象编程的基本实现

> 如果需要实例一个对象，那么需要先抽象一个类

例如需要创建一个汽车对象

首先需要抽象一个汽车类：汽车类就相当于一个设计图纸一样。

由这个设计图纸去创建(实例)出来的真实汽车就是一个对象



如何创建一个类，通过class关键字来定义一个类

示例：

```python
# 定义一个汽车的类
class Cart():
    pass
    
'''
类名的书写规范，建议使用驼峰命名法
    大驼峰：MyCar XiaoMi
    小驼峰：myCar xiaoMi
'''
```

类中需要声明什么内容？

```
一个类有特征和功能两个内容组成：
    特征就是一个描述：颜色：白色，品牌：奥迪，排量：2.4 。。。
    功能就是一个能力：拉货，带美女兜风。。。。

    特征在编程中就是一个变量，在类中称为 属性
    功能在编程中就是一个函数，在类中称为 方法

类中属性一般定义在前面，方法定义在后面
```

示例：

```python
# 定义一个汽车的类
class Cart():
    # 属性 ==> 特征 ==> 变量
    color = '白色'  # 表示颜色属性
    brand = '奥迪'  # 表示品牌属性
    pailiang = 2.4 # 表示排列属性

    # 方法 ==> 功能 ==> 函数
    def luohuo(self):
        print('小汽车能拉货')

    def doufeng(self):
        print('小汽车能兜风')

    def bamei(self):
        print('带妹子去嗨。。。')
```

如何通过类实例化对象并使用？

```python
# 如何去使用这个类？
# 通过类实例化一个对象
aodiobj =  Cart()

# print(aodiobj,type(aodiobj))
# <__main__.Cart object at 0x106f08550> <class '__main__.Cart'>

# 调用对象的方法
aodiobj.bamei()

# 获取对象的属性
print(aodiobj.brand)
```

### 成员属性和成员方法的操作

#### 对象操作成员

```
成员属性：
  访问：  对象.成员属性名
  修改：  对象.成员属性名法 = 新值。（此时等于给这个对象创建了一个自己的属性）
  添加：  对象.新成员属性 = 值 (此时是给这个对象自己新建了一个属性)
  删除：  del 对象.成员属性 (注意：只能删除这个对象自己的属性)
  
成员方法：
  访问：  对象.成员方法名()
  修改：  对象.成员方法名 = func（此时等于给这个对象创建了一个自己的方法）
  添加：  对象.方法名 = func (此时是给这个对象自己新建了一个方法)
  删除：  del 对象.方法名 (注意：只能删除这个对象自己的方法)
```

#### 类操作成员（不推荐）

```
成员属性：
  访问：  类名.成员属性名
  修改：  类名.成员属性名法 = 新值。（此时通过这个类创建的对象都具有这个属性）
  添加：  类名.新成员属性 = 值 (此时通过这个类创建的对象都具有这个属性)
  删除：  del 类名.成员属性 (注意：删除这个类的属性后，这个类创建的对象也没有这几个属性了)
  
成员方法：
  访问：  类名.成员方法名()
  修改：  类名.成员方法名 = func（此时通过类创建的对象都被修改）
  添加：  类名.方法名 = func (此时通过类创建的对象都被修改)
  删除：  del 类名.方法名 (注意：此时通过类创建的对象都被修改)
```

#### 总结

+ 一个类可以实例化出多个对象，每个对象在内存中都独立存在的
+ 当通过类实例化对象时，并不会把类中的成员复制一份给对象，而去给对象了一个引用
+ 访问对象成员的时候，如果对象自己没有这个成员，对象会向实例化它的类去查找
+ 对象成员的添加和修改，都只会影响当前对象自己，不会影响类和其它对象
+ 删除对象的成员时，必须是该对象自己具备的成员才可以，不能删除类中引用的成员
+ 对类的成员操作，会影响通过这个类创建的对象，包括之前创建的。

# 19、面向对象高阶-描述符与设计模式

## 描述符

> 当一个类中，包含了三个魔术方法(`__get__,__set__,__delete__`)之一，或者全部时，那么这个类就称为描述符类

### 作用

> 描述符的作用就是对一个类中的某个成员进行一个详细的管理操作（获取，赋值，删除）
> 描述符就是代理了一个类中的成员的操作，描述符属于类，只能定义为类的属性

### 三个魔术方法

```python
'''
__get__(self, instance, owner)
	触发机制：在访问对象成员属性时自动触发(当该成员已经交给描述符管理时)
	作用：设置当前属性获取的值
	参数：1. self 描述符对象 2.被管理成员的类的对象。3.被管理成员的类
	返回值：返回值作为成员属性获取的值
	注意事项：无
__set__(self, instance, value)
	触发机制：在设置对象成员属性时自动触发(当该成员已经交给描述符管理时)
	作用：对成员的赋值进行管理
	参数：1. self 描述符对象 2.被管理成员的类的对象。3.要设置的值
	返回值：无
	注意事项：无
__delete__(self, instance)
	触发机制：在删除对象成员属性时自动触发(当该成员已经交给描述符管理时)
	作用：对成员属性的删除进行管理
	参数：1. self 描述符对象 2.被管理成员的类的对象。
	返回值：无
	注意事项：无
'''
```

### 数据描述符：（完整）

> 同时具备三个魔术方法的类就是 数据描述符

### 非数据描述符：（不完整）

> 没有同时具备三个魔术方法的类就是 非描述符类

### 基本使用格式

> 把当前的描述符类赋值给一个需要代理的类中的成员属性

代码示例：

```python
# 定义描述符类
class PersonName():
    __name = 'abc'

    def __get__(self, instance, owner):
        # print(self,instance,owner)
        return self.__name

    def __set__(self, instance, value):
        # print(self,instance,value)
        self.__name = value

    def __delete__(self, instance):
        # print(self,instance)
        # del self.__name
        print('不允许删除')

# 定义的普通类
class Person():
    # 把类中的一个成员属性交给一个描述符类来实现
    # 一个类中的成员的值是另一个描述符类的对象()
    # 那么当对这个类中得成员进行操作时，可以理解为就是对另一个对象的操作
    name = PersonName()

# 实例化对象
zs = Person()
print(zs.name)
zs.name = '张三'
print(zs.name)
del zs.name
print(zs.name)
```

### 描述符应用解析

```python
#定义一个学生类，需要记录 学员的id，名字，分数
class Student():
    def __init__(self,id,name,score):
        self.id = id
        self.name = name
        self.score = score

    def returnMe(self):
        info =  f'''
        学员编号:{self.id}
        学员姓名:{self.name}
        学员分数:{self.score}
        '''
        print(info)
'''
# 要求：学员的分数只能在0-100范围中
解决方法：
    1。在__init__方法中检测当前分数范围
         # 检测分数范围
        if score >= 0 and score <= 100:
            self.score = score
        这个解决方案只能在对象初始化时有效。
    2。 定义一个setattr魔术方法检测
        检测如果给score分数进行赋值时，进行分数的检测判断
            def __setattr__(self, key, value):
        # 检测是否是给score进行赋值操作
        if key == 'score':
            # 检测分数范围
            if value >= 0 and value <= 100:
                object.__setattr__(self, key, value)
            else:
                print('当前分数不符合要求')
        else:
            object.__setattr__(self,key,value)

        假如 学员的分数不止一个时怎么办，比如 语文分数，数学分数，英语分数
        另外就是当前这个类中的代码是否就比较多了呢？

    3。可以思考使用描述符来代理我们的分数这个属性
        1.定义Score描述符类
        2.把学生类中的score这个成员交给描述符类进行代理
        3.只要在代理的描述符类中对分数进行赋值和获取就ok了
'''

#定义描述符类 代理分数的管理
class Score():
    def __get__(self, instance, owner):
        return self.__score
    def __set__(self, instance, value):
        if value >= 0 and value <= 100:
            self.__score = value
        else:
            print('分数不符合要求')

# 使用描述符类代理score分数属性
class Student():
    score = Score()
    def __init__(self,id,name,score):
        self.id = id
        self.name = name
        self.score = score

    def returnMe(self):
        info =  f'''
        学员编号:{self.id}
        学员姓名:{self.name}
        学员分数:{self.score}
        '''
        print(info)



# 实例化对象
zs = Student(1011,'张三疯',99)
zs.returnMe()
zs.score = -20
zs.score = 88
zs.returnMe()

```

### 描述符的三种定义格式

```python
# 格式一 通过定义 描述符类来实现  推荐
'''
class ScoreManage():
    def __get__(self, instance, owner):
        pass
    def __set__(self, instance, value):
        pass
    def __delete__(self, instance):
        pass

class Student():
    score = ScoreManage()
'''

# 格式二， 使用 property 函数 来实现
'''
class Student():

    # 在当前需要被管理的类中 直接定义类似下面三个方法
    def getscore(self):
        print('getscore')

    def setscore(self,value):
        print('setscore',value)

    def delscore(self):
        print('delscore')

    # 在 property 函数中指定对应的三个方法,对应的方法 1。__get__，2。__set__,3。__delete__
    score = property(getscore,setscore,delscore)

zs = Student()
# print(zs.score)
# zs.score = 200
# del zs.score
'''

# 格式三 使用 @property 装饰器语法来实现
'''
class Student():
    __score = None

    @property
    def score(self):
        print('get')
        return self.__score

    @score.setter
    def score(self,value):
        print('set')
        self.__score = value

    @score.deleter
    def score(self):
        print('delete')
        del self.__score

zs = Student()
# print(zs.score)
zs.score = 199
print(zs.score)
del zs.score
'''
```

## 设计模式

> 设计模式是前人为完成某个功能或需求，根据经验和总结，对实现的代码步骤和代码设计进行了总结和归纳，成为了实现某个需求的经典模式。
>
> 设计模式并不是固定的代码格式，而是一种面向对象编程的设计

### 单例(单态)设计模式

> 在当前脚本中，同一个类只能创建出一个对象去使用。这种情况就成为单例(单态)。

```python
'''
实现单例的案例，思考：
单例和婚姻法的关系，特别像，一个人只能有一个结婚对象
在社会中是如何完成一夫一妻制的？
如果要结婚，必须要到 民政局 登记
民政局 需要检测两个人的户口本，看上面是否属于 结婚的状态
如果是已婚，肯定就撵出去了。
如果没有结婚，可以给盖个章了，开始登记。

那么按照这样的思路如何去实现 python中的单例设计模式呢？

1。需要有一个方法，可以去控制当前对象的创建过程？
    构造方法 __new__
2。需要有一个标示来存储和表示是否有对象
    创建一个私有属性 进行存储，默认值为None
3。在创建对象的方法中去检测和判断是否有对象？
    如果没有对象，则创建对象，并且把对象存储起来，返回对象
    如果存储的是对象，则直接返回对象，就不需要创建新的对象了
'''

class Demo():
    # 2.定义私有属性存储对象，默认值为None
    __obj = None

    # 1.定义构造方法
    def __new__(cls, *args, **kwargs):
        # 3。在创建对象的过程中，判断是否有对象
        if not cls.__obj:
            # 判断如果没有对象，则创建对象，并且存储起来
            cls.__obj = object.__new__(cls)
        # 直接把存储的对象返回
        return cls.__obj


# 实例化对象
a = Demo()
b = Demo()
print(a)
print(b)
'''
<__main__.Demo object at 0x106f4d850>
<__main__.Demo object at 0x106f4d850>
'''
```

### Mixin 混合设计模式

#### Mixin类

+ Mixin 必须是表示一种功能，而不是一个对象。
+ Mixin 的功能必须单一，如果有多个功能，那就多定义Mixin类
+ python 中的Mixin是通过多继承实现的
+ Mixin 这个类通常不单独使用，而是混合到其它类中，去增加功能的
+ Mixin 类不依赖子类的实现，即便子类没有继承这个Mixin,子类也能正常运行，可能就是缺少了一些功能。。

#### 使用Mixin混入类的好处？

1. Mixin 这个混入类的设计模式，在不对类的内容修改的前提下，扩展了类的功能

2. Mixin 混入类为了提高代码的重用性，使得代码结构更加简单清晰

3. 可以根据开发需要任意调整功能（创建新的Mixin混入类）避免设计多层次的复杂的继承关系。

示例：

```python
'''
继承需要有一个必要的前提，继承应该是一个 'is-a' 的关系
例如：
    苹果可以去继承水果，因为苹果就是一个水果
    苹果不能继承午饭，因为午饭可以有苹果也可以没有

    比如 汽车可以继承 交通工具，因为汽车本身就是一个交通工具

交通工具有哪些？
汽车，飞机，直升机，这些都属于 交通工具
那么如何去设计这些类的关系呢？
比如创建一个交通工具类，然后属于交通工具的都来继承，再去实现。。。
但是，飞机和直升机都有飞行的功能，而汽车并没有，那么在交通工具中如果去定义 飞行这个功能，那就不太合适了。。
能不能在飞机和直升机类中分别实现 飞行 这个功能呢？可以，但是代码又无法重用。

怎么办？
单独去定义交通工具类，和 飞行器 这个两个父类，这样飞机和直升机就可以去继承这两个类.
'''

# 交通工具 vehicle
class vehicle():
    # 运输货物
    def huo(self):
        print('运输货物')
    # 搭载乘客
    def ren(self):
        print('搭载乘客')

# 飞行器
class FlyingMixin():
    def fly(self):
        print('可以起飞了。。。')

# 定义汽车类
class cart(vehicle):
    pass

# 定义飞机
class airplane(vehicle,FlyingMixin):
    pass

# 定义直升机
class helicopter(vehicle,FlyingMixin):
    pass

# 此时去定义一个飞行器的类 Flying，让需要飞行的交通工具，直接继承这个类。可以解决这个问题。
# 但是，1。出现类多继承，违背了'is-a'  2。飞行器这个类很容易被误解
# 解决方案也是使用多继承，但是给飞行器这个类，定义成为一个 Mixin 混合类,
# 此时就是等于把飞行器这个类，作为了一个扩展的功能，来扩展其它类

'''
在上面的代码中，虽然直升机和飞机都使用了多继承，也就是继承了FlyingMixin
但是由于 FlyingMixin 类加了 Minin这个名，就告诉了后面阅读代码的人，这个类是一个Mixin类
'''
```



### 抽象类（了解）

> ```
> 抽象类是一个特殊的类：
>     1. 抽象类不能用，不能直接实例化成为一个对象。
>     2. 抽象类中包含了抽象方法，抽象方法就是没有实现代码的方法。
>     3. 抽象类需要子类继承，并重写父类的抽象方法。才可以使用。
> ```

```
抽象类，一般应用在程序设计，程序设计中一般是要对功能和需求进行规划，其中有一些需求是明确的并且可以完成的，
但是也可能会有一些需求是不明确的，或者不确定具体需要怎么实现，
那么此时就可以把这个不确定怎么实现或者需要后面再去实现的方法，定义为抽象方法（只定义方法名，不写具体代码）

抽象类的应用：
    例如要开发一个框架，这个框架要有一些基本功能和扩展功能。。。。
    但是你具体用这个框架开发什么样的产品，开发框架的人并不清楚或者确定。
    因此框架就具备一定的功能，并且留下来一些方法的定义，剩下的就是需要自己在方法中具体实现自己业务逻辑。
```

抽象类的定义：

```python
import abc

# 如果要定义为抽象类，那么这个类的 metaclass属性必须是 metaclass=abc.ABCMeta
class WriteCode(metaclass=abc.ABCMeta):

    #需要抽象的方法，使用装饰器进行装饰
    @abc.abstractmethod
    def write_php(self):
        pass

    def write_java(self):
        print('实现了java代码的开发')

    def write_python(self):
        print('实现了python代码的开发')


# 抽象类不能直接实例化对象
# obj = WriteCode()
# print(obj)
#TypeError: Can't instantiate abstract class WriteCode with abstract methods write_php


# 定义子类，继承抽象类，并实现抽象类中的抽象方法
class Demo(WriteCode):
    def write_php(self):
        print('实现了php代码的开发')

a = Demo()
print(a)
a.write_java()
a.write_php()
a.write_python()
```

# 20、装饰器 decorator



### 装饰器定义

**在不改变原有函数代码，且保持原函数调用方法不变的情况下，给原函数增加新的功能(或者给类增加属性和方法)**
**核心思想**：用一个函数（或者类）去装饰一个旧函数（或者类），造出一个新函数（或者新类）
**应用场景**：引入日志，函数执行时间的统计，执行函数前的准备工作，执行函数后的处理工作，权限校验，缓存等
**语法规则**：在原有的函数上加上 @符，装饰器会把下面的函数当作参数传递到装饰器中，@符又被成为 语法糖

#### 1.装饰器原型（闭包）

```python
# 1。 装饰器的原型
### 利用闭包，把函数当作参数传递，并且在函数内去调用传递进来的函数，并返回一个函数
# 定义外函数，接收一个函数作为参数
def outer(f):
    # 定义内函数，并且在内函数中调用了外函数的参数
    def inner():
        print('我是外函数中的内函数1')
        f()
        print('我是外函数中的内函数2')
    return inner

# 定义普通函数
# def old():
#     print('我是一个普通的函数')
#
# # old()  # 作为普通函数直接调用
# old = outer(old)  # outer返回了inner函数，赋值给了old
# old()             # 此时再调用old函数时，等同于调用了 inner 函数


# 改为装饰器用法
@outer      # 此处使用的@outer的语法就是把outer作为了装饰器，等同于 old = outer(old)
def old():
    print('我是一个普通的函数')

old()  # old函数经过 outer装饰器进行了装饰，代码和调用方法不变，但是函数的功能发送了改变
```

#### 2.装饰器的应用：统计函数的执行时间

```python
# 装饰器应用场景-统计函数执行时间
import time

# 定义一个统计函数执行时间的 装饰器
def runtime(f):
    def inner():
        start = time.perf_counter()
        f()
        end =  time.perf_counter() - start
        print(f'函数的调用执行时间为：{end}')
    return inner

# 定义一个函数
@runtime
def func():
    for i in range(5):
        print(i,end=" ")
        time.sleep(1)

func()
```

#### 3.装饰器嵌套语法

```python
# 1.定义装饰器
# 外函数
def outer(func):
    #内函数
    def inner():
        print('找到妹子，成功拿到微信。。。3')
        func()  # 在内函数中调用外函数中的行参-函数
        print('约妹子，看一场午夜电影。。。4')
    # 在外函数中返回内函数
    return inner

# 2。在定义一个装饰器
def kuozhan(f):
    def kzinner():
        print('扩展1')
        f()
        print('扩展2')
    return kzinner

# 3. 装饰器的嵌套 先执行下面的，再执行上面的。
@kuozhan # 2。再使用上面的 kuozhan 装饰器，装饰 上一次返回的 inner 函数，又返回了 kzinner 函数
@outer   # 1。先使用离得近的 outer装饰器 装饰love函数，返回了一个 inner函数
def love():
    print('跟妹子畅谈人生和理想。。。5')

love()
''' 结果和过程的解析
1 3 5 4 2
1 先使用离得近的 outer装饰器 装饰love函数，返回了一个 inner函数
2 再使用上面的 kuozhan 装饰器，装饰 上一次返回的 inner 函数，又返回了 kzinner 函数

最后在调用love函数的时候是怎么执行的
    love() == kzinner()
                ===>  1
                ===>  inner()  
                           ===> 3
                           ===> love() ===> 5
                           ===> 4
                ===>  2
'''
```

#### 4.对带有参数的函数进行装饰

```python
# 定义装饰器
def outer(func):
    # 如果装饰器带有参数的函数，需要在内函数中定义行参，并传递给调用的函数。因为调用原函数等于调用内函数
    def inner(var):
        print(f'找到{var}妹子，成功拿到微信。。')
        func(var)
        print(f'约{var}妹子，看一场午夜电影。。')
    return inner

# 有参数的函数
@outer
def love(name):
    print(f'跟{name}妹子畅谈人生。。。')

love('思思') #love() ==> inner()   love('思思') ===> inner('思思')

```

#### 5.对多参数的函数进行装饰

```python
# 装饰带有多参数的函数
def outer(func):
    def inner(who,name,*args,**kwargs):
        print('约到妹子，聊微信。。。')
        func(who,name,*args,**kwargs)
        print('天色一晚，怎么办？')
    return inner


# 定义多参数的 函数
@outer
def love(who,name,*args,**kwargs):
    print(f'{who}跟{name}畅谈人生。。。')
    print('完事去吃了好多美食',args)
    print('看了一场电影',kwargs)

love('三多','思思','火锅','辣条','7块钱的麻辣烫',mov='唐山大地震')
'''
love() ==> inner()
    love(...) ==> inner(...)
        inner(...) ==> love(...)
'''
```

#### 6.带有参数的装饰器

> 你会遇到带有参数的装饰器，例如Django框架中的 @login_required(login_url='/accounts/login/')

```python
# 如果你的装饰器需要有参数，那么给当前的装饰器套一个壳，用于接收装饰器的参数
def kuozhan(var):
    def outer(func):
        def inner1():
            print('妹子给了你微信')
            func()
        def inner2():
            print('妹子给介绍了个大妈')
            func()
        # 装饰器壳的参数，可以用于在函数内去做流程控制
        if var == 1:
            return inner1
        else:
            return inner2
    return outer


@kuozhan(2) # kuozhan(var) ==> outer() ==> outer(love) ==> inner()
def love():
    print('谈谈人生。。。')

love()
```

#### 7.用类装饰器装饰函数

```python
# 类装饰器装饰函数
class Outer():
    # 魔术方法：当把该类的对象当作函数调用时，自动触发 obj()
    def __call__(self,func):
        self.func = func  # 把传进来的函数作为对象的成员方法
        return self.inner # 返回一个函数

    # 在定义的需要返回的新方法中 去进行装饰和处理
    def inner(self,who):
        print('拿到妹子的微信。。。')
        self.func(who)
        print('看一场午夜电影。。。')

@Outer()  # Outer() ==> obj  @obj==>obj(love) ==> __call__(love) ==> inner()
def love(who):
    print(f'{who}和妹子谈谈人生和理想。。。')

love('川哥') # inner('川哥')
print(love) # 此时的 love就是属于Outer类这个对象中的inner方法
```

#### 8.用类方法装饰函数

```python
# 用类方法装饰函数
class Outer():
    def newinner(func):
        Outer.func = func  # 把传递进来的函数定义为类方法
        return Outer.inner # 同时返回一个新的类方法

    def inner():
        print('拿到妹子微信')
        Outer.func()
        print('看一场午夜电影')


@Outer.newinner  # Outer.newinner(love) ==> Outer.inner
def love():
    print('和妹子谈谈人生喝喝茶。。。')
love()          # love()  ==> Outer.inner()
```

到目前为止以上所以形式的装饰器，包括 函数装饰器，类装饰器，类方法装饰器，都有一个共同特点：都是在给函数去进行装饰，增加功能。

---



### 用装饰器装饰类

> 还有一种装饰器，是专门装饰类的。也就是在类的定义的前面使用@装饰器这种语法
> @装饰器
> class Demo():
>  pass

> 装饰器给函数进行装饰，目的是不改变函数调用和代码的情况下给原函数增加了新的功能。

> 装饰器给类进行装饰，目的是不改变类的定义和调用的情况下给类增加新的成员（属性或方法）。

#### 9.用函数装饰器装饰类

```python
# 使用函数装饰器，给类进行装饰，增加新的属性和方法

# 定义函数，接收一个类。返回修改后的类
def kuozhan(cls):
    def func2():
        print('我是在装饰器中追加的新方法，func2')
    cls.func2 = func2 # 把刚才定义的方法赋值给 类
    cls.name = '我是在装饰器中追加的新属性 name'

    #返回时，把追加类新成员的 类 返回去
    return cls


@kuozhan   # kuozhan(Demo) ==> cls ==> Demo
class Demo():
    def func():
        print('我是Demo类中定义的func方法')

Demo.func() # 此时在调用的Demo类是通过装饰器，更新过的Demo类
Demo.func2()
print(Demo.name)
```

#### 10.使用类装饰器装饰类

```python
class KuoZhan():
    def __call__(self, cls):
        # 把接收的类，赋值给当前对象，作为一个属性
        self.cls = cls
        # 返回一个函数
        return self.newfunc

    def newfunc(self):
        self.cls.name = '我是在类装饰器中追加的新属性 name'
        self.cls.func2 = self.func2
        # 返回传递进来的类的实例化结果，obj
        return self.cls()

    def func2(self):
        print('我是在类装饰器中追加的新方法 func2')



@KuoZhan()  # KuoZhan() ==> obj ==> @obj(Demo) ==> __call__(Demo) ==> newfunc
class Demo():
    def func(self):
        print('我是Demo类中定义的func方法')

obj = Demo()  # Demo() ==> newfunc() ==> obj
obj.func()
obj.func2()
print(obj.name)

# 思考： 此时的 obj这个对象，是哪个类的对象。Demo还是KuoZhan
print(obj) # 此时的obj依然是Demo类的实例化对象，只不过经过装饰后，增加了新的属性和方法
```



作业：如何用一个装饰器，装饰带有返回值的函数

# 21、面向对象-高阶

### 内置成员

```python
# 获取类/对象的所属成员 类/对象.__dict__
res = Demo.__dict__  # 获取当前类的所属成员
res = obj.__dict__   # 获取当前对象的所属成员

# 获取类的文档信息 类/对象.__doc__
res = Demo.__doc__
res = obj.__doc__

# 获取类名称组成的字符串
res = Demo.__name__

# 获取类所在的文件名称，如果是当前文件，显示为__main__
res = Demo.__module__

# __bases__ 获取当前类的父类列表
res = Demo.__base__ # 获取继承的第一个父类
res = Demo.__bases__ # 获取继承的所有的父类列表

# MRO列表  获取当前类的继承链
res = Demo.__mro__
```



### 方法的分类

```python
1. 对象方法
    特征：
        1. 在类中定义的方法，含有self参数
        2. 含有self的方法，只能使用对象进行调用
        3. 该方法会把调用的对象传递进来

2. 类方法
    特征：
        1。在类中定义的方法，使用装饰器 @classmethod 进行了装饰
        2。方法中有cls这个行参。不需要实例化对象，直接使用类进行调用
        3。会把调用这个方法的类传递进来

3. 绑定类方法
    特征：
        1。在类中定义的方法
        2。只能使用类进行调用
        3。不会传递对象或者类进来

4. 静态方法
    特征：
        1。在类中定义的方法，使用了 装饰器 @staticmethod 进行了装饰
        2。可以使用对象或者类进行调用
        3。不会传递对象或者类进来
```



### 常用函数

```python
# 检测类和对象相关
# issubclass(子类,父类) # 检测一个类是否为另一个类的子类
# res = issubclass(D,B)

# isinstance(对象,类) # 检测一个对象是否是该类或该类的子类的实例化结果
# res = isinstance(d,A)

# 操作类和对象成员相关
# hasattr(对象/类,'成员名称')  检测类/对象是否包含指定名称的成员
# res = hasattr(d,'name')

#getattr(对象/类,'成员名称') # 获取类/对象的成员的值
# res = getattr(d,'say')

# setattr(对象/类,'成员名称','成员的值') 设置类/对象的成员的属性值
res = setattr(d,'name','ooo')
# print(d.name)

#delattr(类/对象,'成员名称') 删除类/对象的成员属性 和 del 直接删除对象的成员是一样的结果
# delattr(D,'name')

# dir() #获取当前对象所以可以访问的成员的列表
res = dir(d)
```



### 魔术方法

> 魔术方法就是不需要手动调用就可以自动执行的方法

```python
1. __init__ 初始化方法  *****
    触发机制：当实例化对象之后就会立即触发的方法
    作用：   为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，方法的调用，打开或创建一些资源。。
    参数：   一个self，接受当前对象，其它参数根据需求进行定义即可
    返回值： 无
    注意事项：无

2. __new__ 构造方法    ****
    触发机制：实例化对象时自动触发（在__init__之前触发）
    作用：   管理控制对象创建的过程
    参数：   一个cls 接收当前类，其它参数根据初始化方法的参数进行决定
    返回值： 必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None
    注意事项：
            __new__方法的参数和__init__方法的参数要保持一致，除了第一个参数
            必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None
    应用场景：设计模式中的单例设计模式


3. __del__ 析构方法    *****
    触发机制：当该类对象被销毁时，自动触发
    作用： 关闭或释放对象创建时打开或创建的一些资源
    参数： 一个self，接受当前的对象
    返回值：无
    注意事项： 无

4. __call__          ***
    触发机制： 把对象当作函数直接调用时自动触发
    作用：    一般用于归纳类或对象的操作步骤，方便调用
    参数：   一个self接收当前对象，其它参数根据调用需求缺点
    返回值：  可有可无
 
5.__len__
    触发机制： 当使用len函数去检测当前对象的时候自动触发
    作用：    可以使用len函数检测当前对象中某个数据的信息
    参数：    一个self 接收当前对象
    返回值：  必须有，并且必须是一个整型
    注意事项：len要获取什么属性的值，就在返回值中返回哪个属性的长度即可

6.__str__
    触发机制： 当使用str或者print函数对对象进行操作时自动触发
    作用：   代码对象进行字符串的返回，可以自定义打印的信息
    参数：  一个self，接收当前对象
    返回值： 必须有，而去必须是字符串类型的值

7.__repr__
    触发机制：在使用repr方法对当前对象进行转换时自动触发
    作用： 可以设置repr函数操作对象的结果
    参数：  一个self，接收当前对象
    返回值： 必须有，而去必须是字符串类型的值
    注意：正常情况下，如果没有__str__这个魔术方法，__repr__方法就会代替__str__魔术方法

8.__bool__
    触发机制： 当前使用bool函数转换当前对象时，自动触发.默认情况下，对象会转为True
    作用：    可以代替对象进行bool类型的转换，可以转换任何数据
    参数 ：   一个self 接收对象
    返回值： 必须是一个布尔类型的返回值
```

### 设计模式

# 22、面向对象-高阶-内置成员和魔术方法



### 内置成员

```python
# 获取类/对象的所属成员 类/对象.__dict__
res = Demo.__dict__  # 获取当前类的所属成员
res = obj.__dict__   # 获取当前对象的所属成员

# 获取类的文档信息 类/对象.__doc__
res = Demo.__doc__
res = obj.__doc__

# 获取类名称组成的字符串
res = Demo.__name__

# 获取类所在的文件名称，如果是当前文件，显示为__main__
res = Demo.__module__

# __bases__ 获取当前类的父类列表
res = Demo.__base__ # 获取继承的第一个父类
res = Demo.__bases__ # 获取继承的所有的父类列表

# MRO列表  获取当前类的继承链
res = Demo.__mro__
```



### 方法的分类

```python
1. 对象方法
    特征：
        1. 在类中定义的方法，含有self参数
        2. 含有self的方法，只能使用对象进行调用
        3. 该方法会把调用的对象传递进来

2. 类方法
    特征：
        1。在类中定义的方法，使用装饰器 @classmethod 进行了装饰
        2。方法中有cls这个行参。不需要实例化对象，直接使用类进行调用
        3。会把调用这个方法的类传递进来

3. 绑定类方法
    特征：
        1。在类中定义的方法
        2。只能使用类进行调用
        3。不会传递对象或者类进来

4. 静态方法
    特征：
        1。在类中定义的方法，使用了 装饰器 @staticmethod 进行了装饰
        2。可以使用对象或者类进行调用
        3。不会传递对象或者类进来
```



### 常用函数

```python
# 检测类和对象相关
# issubclass(子类,父类) # 检测一个类是否为另一个类的子类
# res = issubclass(D,B)

# isinstance(对象,类) # 检测一个对象是否是该类或该类的子类的实例化结果
# res = isinstance(d,A)

# 操作类和对象成员相关
# hasattr(对象/类,'成员名称')  检测类/对象是否包含指定名称的成员
# res = hasattr(d,'name')

#getattr(对象/类,'成员名称') # 获取类/对象的成员的值
# res = getattr(d,'say')

# setattr(对象/类,'成员名称','成员的值') 设置类/对象的成员的属性值
res = setattr(d,'name','ooo')
# print(d.name)

#delattr(类/对象,'成员名称') 删除类/对象的成员属性 和 del 直接删除对象的成员是一样的结果
# delattr(D,'name')

# dir() #获取当前对象所以可以访问的成员的列表
res = dir(d)
```



### 魔术方法

> 魔术方法就是不需要手动调用就可以自动执行的方法

```python
1. __init__ 初始化方法  *****
    触发机制：当实例化对象之后就会立即触发的方法
    作用：   为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，方法的调用，打开或创建一些资源。。
    参数：   一个self，接受当前对象，其它参数根据需求进行定义即可
    返回值： 无
    注意事项：无

2. __new__ 构造方法    ****
    触发机制：实例化对象时自动触发（在__init__之前触发）
    作用：   管理控制对象创建的过程
    参数：   一个cls 接收当前类，其它参数根据初始化方法的参数进行决定
    返回值： 必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None
    注意事项：
            __new__方法的参数和__init__方法的参数要保持一致，除了第一个参数
            必须返回object.__new__(cls)进行对象的创建，如果没有返回值，则实例化对象的结果为None
    应用场景：设计模式中的单例设计模式


3. __del__ 析构方法    *****
    触发机制：当该类对象被销毁时，自动触发
    作用： 关闭或释放对象创建时打开或创建的一些资源
    参数： 一个self，接受当前的对象
    返回值：无
    注意事项： 无

4. __call__          ***
    触发机制： 把对象当作函数直接调用时自动触发
    作用：    一般用于归纳类或对象的操作步骤，方便调用
    参数：   一个self接收当前对象，其它参数根据调用需求缺点
    返回值：  可有可无
 
5.__len__
    触发机制： 当使用len函数去检测当前对象的时候自动触发
    作用：    可以使用len函数检测当前对象中某个数据的信息
    参数：    一个self 接收当前对象
    返回值：  必须有，并且必须是一个整型
    注意事项：len要获取什么属性的值，就在返回值中返回哪个属性的长度即可

6.__str__
    触发机制： 当使用str或者print函数对对象进行操作时自动触发
    作用：   代码对象进行字符串的返回，可以自定义打印的信息
    参数：  一个self，接收当前对象
    返回值： 必须有，而去必须是字符串类型的值

7.__repr__
    触发机制：在使用repr方法对当前对象进行转换时自动触发
    作用： 可以设置repr函数操作对象的结果
    参数：  一个self，接收当前对象
    返回值： 必须有，而去必须是字符串类型的值
    注意：正常情况下，如果没有__str__这个魔术方法，__repr__方法就会代替__str__魔术方法

8.__bool__
    触发机制： 当前使用bool函数转换当前对象时，自动触发.默认情况下，对象会转为True
    作用：    可以代替对象进行bool类型的转换，可以转换任何数据
    参数 ：   一个self 接收对象
    返回值： 必须是一个布尔类型的返回值
```

### 成员相关魔术方法

```python
## 1. __getattribute__   优先级最高
    触发机制：当访问对象成员时，自动触发，无论当前成员是否存在
    作用：   可以在获取对象成员时，对数据进行一些处理
    参数：   一个self接收对象，一个item接收当前访问的成员名称
    返回值： 可有可无，返回的值就是访问的结果
    注意事项：在当前的魔术方法中，禁止对当前对象的成员进行访问，会触发递归。
            如果想要在当前魔术方法中访问对象的成员必须使用 object 来进行访问
            格式： object.__getattribute__(self,item)

## 2. __getattr__
    触发机制： 当访问对象中不存在的成员时，自动触发
    作用：  防止访问不存在的成员时报错，也可以为不存在的成员进行赋值操作
    参数：  一个self接收当前对象，一个item接收当前访问的成员名称
    返回值： 可有可无
    注意事项： 当存在 __getattribute__ 方法时，会去执行 __getattribute__ 方法
    					也要注意，不要在当前的方法中再次去访问这个不存在的成员，会触发递归操作

## 3. __setattr__
    触发机制： 当给对象的成员进行赋值操作时会自动触发（包括添加，修改）
    作用：   可以限制或管理对象成员的添加和修改操作
    参数： 1。self 接收当前对象  2。key 设置的成员名  3。val 设置的成员值
    返回值： 无
    注意事项：在当前的魔术方法中禁止给当前对象的成员直接进行赋值操作，会触发递归操作
            如果想要给当前对象的成员进行赋值，需要借助 object
            格式： object.__setattr__(self,key,value)
## 4. __delattr__
    触发机制： 当删除对象成员时自动触发
    作用： 可以去限制对象成员的删除，还可以删除不存在成员时防止报错
    参数：1，self 接收当前对象  2。item 删除的成员名称
    返回值： 无
    注意事项： 在当前魔术方法中禁止直接删除对象的成员，会触发递归操作。
            如果想要删除当前对象的成员，那么需要借助 object
            格式： object.__delattr__(self,item)
```

### 访问成员的顺序！！！

1. 调用 `__getattribute__ `魔术方法
2. 调用数据描述符【后面会讲】
3. 调用当前对象的成员
4. 调用当前类的成员
5. 调用非数据描述符【后面会讲】
6. 调用父类的成员
7. 调用`__getattr__`魔术方法

> 以上步骤时调用某个成员时的顺序，前面的能够调用成功，后面则不在执行

# 23、异常



### 什么是异常？

> 异常简单理解，就是非正常，没有达到预期目标。
> 异常是一个事件，并且这个异常事件在我们程序员的运行过程中出现，会影响我们程序正常执行。

异常分两种：
    1. 语法错误导致的异常
    2. 逻辑错误导致的异常

### 如何处理异常？

1. 如果错误发生的情况是可以预知的，那么就可以使用流程控制进行预防处理

```python
#比如： 两个数字的运算，其中一个不是数字，运算就会出错。这时可以去判断来预防
n2 = 3
if isinstance(n2,int):
    res = 10+n2
    print(res)
```

2. 如果错误的发生条件不可预知，就可以使用 try。。。except。。 在错误发生时进行处理

```python
'''语法：
try:
    可能发生异常错误的代码
except:
    如果发生异常则进入 except 代码块进行处理
'''

# 假设读取的文件不存在，会发生错误，可以使用两种方式进行处理，
# 1。可以在文件读取前先判断当前的文件是否存在
# 2。也可以使用try 。。。 except。。在错误发生时进行处理
try:
    with open('./user.txt','r') as fp:
        res = fp.read()
    print(res)
except:
    print('文件不存在')

print('程序的继续执行。。。')
```

**注意：try。。except。。是在错误发生后进行的处理。和if有着根本性的区别。**



### Try。。。except。。详细用法

```python
# try。。except 详细用法


# 1。使用try。。except 处理指定的异常。如果引发了非指定的异常，则无法处理
try:
    s1 = 'hello'
    int(s1) # 会引发 ValueError
except ValueError as e:
# except IndexError as e:  #如果引发了非指定的异常，则无法处理
    print(e)


# 2。 多分支处理异常类.不同的异常会走向不同的except处理
s1 = 'hello'
try:
    # int(s1) # ValueError
    s1[5]    # IndexError
except IndexError as e:
    print('IndexError',e)
except KeyError as e:
    print('KeyError',e)
except ValueError as e:
    print('ValueError',e)


# 3。通用异常类 Exception
s1 = 'world'
try:
    int(s1)
except Exception as e:
    print('Exception ===',e)


# 4. 多分支异常类+通用异常类.这样引发异常后会按照从上往下的顺序去执行对应的异常处理类。
s1 = 'hello'
try:
    # int(s1) # ValueError
    s1[5]    # IndexError
except IndexError as e:
    print('IndexError',e)
except KeyError as e:
    print('KeyError',e)
except ValueError as e:
    print('ValueError',e)
except Exception as e:
    print('Exception',e)


# 5。 try...except...else...
s1 = 'hello'
try:
    str(s1)
except IndexError as e:
    print('IndexError',e)
except ValueError as e:
    print('ValueError',e)
except Exception as e:
    print('Exception',e)
else:
    print('try代码块中没有引发异常时，执行')

# 6。try...except..else..finally
# finally 无论是否引发异常，都会执行。通常情况下用于执行一些清理工作。
s1 = 'hello'
try:
    int(s1)
    print('如果前面的代码引发了异常，这个代码块将不在继续执行。。')
except IndexError as e:
    print('IndexError',e)
except ValueError as e:
    print('ValueError',e)
except Exception as e:
    print('Exception',e)
else:
    print('try代码块中没有引发异常时，执行')
finally:
    print('无论是否引发了异常，都会执行这个代码块')

print('如果上面的代码有异常并且进行了处理，那么后面的代码将继续执行')


# 7。使用 raise ，主动抛出异常
try:
    #可以使用 raise 主动抛出异常，并设置异常信息
    raise Exception('发生错误')
except Exception as e:
    print('Exception',e)


#8。 assert 断言
assert 1 == 1 # 如果后面的表达式正确，则什么也不做
assert 2 == 1 # 如果后面的表达式错误，则直接抛出 AssertionError
```

### 自定义异常处理类

> 当异常出现时，对异常信息进行写入日志。

##### traceback 回溯模块  https://docs.python.org/3.7/library/traceback.html

##### logging 日志模块 https://docs.python.org/3.7/library/logging.html

```python
# 自定义异常日志处理类
class Myexception():
    def __init__(self):
        import traceback
        import logging

        # logging的基本配置
        logging.basicConfig(
            filename='./error.log',# 日志存储的文件及目录
            format='%(asctime)s  %(levelname)s \n %(message)s',# 格式化存储的日志格式
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        # 写入日志
        logging.error(traceback.format_exc())

# 使用自定义异常处理类
try:
    int('bb')
except:
    print('在此处进行异常的处理')
    Myexception() # 在异常处理的代码块中去调用自定义异常类
```



### 标准的异常类

|         异常名称          |                        描述                        |
| :-----------------------: | :------------------------------------------------: |
|       BaseException       |                   所有异常的基类                   |
|        SystemExit         |                   解释器请求退出                   |
|     KeyboardInterrupt     |             用户中断执行(通常是输入^C)             |
|         Exception         |                   常规错误的基类                   |
|       StopIteration       |                 迭代器没有更多的值                 |
|       GeneratorExit       |        生成器(generator)发生异常来通知退出         |
|       StandardError       |              所有的内建标准异常的基类              |
|      ArithmeticError      |               所有数值计算错误的基类               |
|    FloatingPointError     |                    浮点计算错误                    |
|       OverflowError       |                数值运算超出最大限制                |
|     ZeroDivisionError     |            除(或取模)零 (所有数据类型)             |
|      AssertionError       |                    断言语句失败                    |
|      AttributeError       |                  对象没有这个属性                  |
|         EOFError          |             没有内建输入,到达EOF 标记              |
|     EnvironmentError      |                 操作系统错误的基类                 |
|          IOError          |                 输入/输出操作失败                  |
|          OSError          |                    操作系统错误                    |
|       WindowsError        |                    系统调用失败                    |
|        ImportError        |                 导入模块/对象失败                  |
|        LookupError        |                 无效数据查询的基类                 |
|        IndexError         |              序列中没有此索引(index)               |
|         KeyError          |                  映射中没有这个键                  |
|        MemoryError        |     内存溢出错误(对于Python 解释器不是致命的)      |
|         NameError         |            未声明/初始化对象 (没有属性)            |
|     UnboundLocalError     |               访问未初始化的本地变量               |
|      ReferenceError       | 弱引用(Weak reference)试图访问已经垃圾回收了的对象 |
|       RuntimeError        |                  一般的运行时错误                  |
|    NotImplementedError    |                   尚未实现的方法                   |
|        SyntaxError        |                  Python 语法错误                   |
|     IndentationError      |                      缩进错误                      |
|         TabError          |                   Tab 和空格混用                   |
|        SystemError        |                一般的解释器系统错误                |
|         TypeError         |                  对类型无效的操作                  |
|        ValueError         |                   传入无效的参数                   |
|       UnicodeError        |                 Unicode 相关的错误                 |
|    UnicodeDecodeError     |                Unicode 解码时的错误                |
|    UnicodeEncodeError     |                 Unicode 编码时错误                 |
|   UnicodeTranslateError   |                 Unicode 转换时错误                 |
|          Warning          |                     警告的基类                     |
|    DeprecationWarning     |               关于被弃用的特征的警告               |
|       FutureWarning       |           关于构造将来语义会有改变的警告           |
|      OverflowWarning      |        旧的关于自动提升为长整型(long)的警告        |
| PendingDeprecationWarning |              关于特性将会被废弃的警告              |
|      RuntimeWarning       |      可疑的运行时行为(runtime behavior)的警告      |
|       SyntaxWarning       |                  可疑的语法的警告                  |
|        UserWarning        |                 用户代码生成的警告                 |

 

